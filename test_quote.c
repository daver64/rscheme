// Generated by RScheme compiler
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

// Forward declarations
typedef struct Environment Environment;

// Scheme object types
typedef enum {
    SCHEME_NIL, SCHEME_BOOLEAN, SCHEME_NUMBER,
    SCHEME_SYMBOL, SCHEME_STRING, SCHEME_PAIR,
    SCHEME_PROCEDURE, SCHEME_PRIMITIVE
} SchemeType;

typedef struct SchemeObject {
    SchemeType type;
    union {
        bool boolean_value;
        double number_value;
        char* string_value;
        char* symbol_name;
        struct { struct SchemeObject* car; struct SchemeObject* cdr; } pair;
        struct {
            struct SchemeObject* parameters;  // List of parameter symbols (for interpreted)
            struct SchemeObject* body;        // List of expressions (for interpreted)
            Environment* closure;             // Captured environment (for interpreted)
            struct SchemeObject* (*func)(struct SchemeObject**, int); // Function pointer (for compiled)
            int arity;                        // Number of parameters
            char* name;                       // Function name (for debugging)
        } procedure;
    } value;
} SchemeObject;

// Runtime functions
SchemeObject* scheme_nil;
SchemeObject* scheme_true;
SchemeObject* scheme_false;

// Function declarations
void scheme_display(SchemeObject* obj);
void scheme_display_list(SchemeObject* obj);
SchemeObject* lookup_variable(const char* name);
void define_variable(const char* name, SchemeObject* value);

// Global variables (simple implementation)
#define MAX_VARS 100
char* var_names[MAX_VARS];
SchemeObject* var_values[MAX_VARS];
int var_count = 0;

// Runtime functions
SchemeObject* scheme_nil;
SchemeObject* scheme_true;
SchemeObject* scheme_false;

SchemeObject* make_number(double value) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_NUMBER;
    obj->value.number_value = value;
    return obj;
}

SchemeObject* make_boolean(bool value) {
    return value ? scheme_true : scheme_false;
}

SchemeObject* make_string(const char* value) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_STRING;
    obj->value.string_value = malloc(strlen(value) + 1);
    strcpy(obj->value.string_value, value);
    return obj;
}

SchemeObject* make_symbol(const char* name) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_SYMBOL;
    obj->value.symbol_name = malloc(strlen(name) + 1);
    strcpy(obj->value.symbol_name, name);
    return obj;
}

SchemeObject* make_pair(SchemeObject* car, SchemeObject* cdr) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PAIR;
    obj->value.pair.car = car;
    obj->value.pair.cdr = cdr;
    return obj;
}

bool is_true(SchemeObject* obj) {
    return obj != scheme_false;
}

bool is_number(SchemeObject* obj) {
    return obj && obj->type == SCHEME_NUMBER;
}

bool is_boolean(SchemeObject* obj) {
    return obj && obj->type == SCHEME_BOOLEAN;
}

bool is_string(SchemeObject* obj) {
    return obj && obj->type == SCHEME_STRING;
}

bool is_pair(SchemeObject* obj) {
    return obj && obj->type == SCHEME_PAIR;
}

bool is_nil(SchemeObject* obj) {
    return obj == scheme_nil;
}

bool is_procedure(SchemeObject* obj) {
    return obj && obj->type == SCHEME_PROCEDURE;
}

bool is_symbol(SchemeObject* obj) {
    return obj && obj->type == SCHEME_SYMBOL;
}

SchemeObject* call_procedure(SchemeObject* proc, SchemeObject** args, int argc) {
    if (!proc || !is_procedure(proc)) {
        return scheme_nil;
    }
    
    // Check if it's a compiled procedure (has func pointer)
    if (proc->value.procedure.func) {
        return proc->value.procedure.func(args, argc);
    }
    
    // For interpreted procedures, we can't handle them in compiled code
    // This would require a full interpreter runtime
    return scheme_nil;
}

SchemeObject* car(SchemeObject* obj) {
    if (is_pair(obj)) return obj->value.pair.car;
    return scheme_nil;
}

SchemeObject* cdr(SchemeObject* obj) {
    if (is_pair(obj)) return obj->value.pair.cdr;
    return scheme_nil;
}

SchemeObject* scheme_add(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value + b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_subtract(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value - b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_multiply(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value * b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_divide(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b) && b->value.number_value != 0) {
        return make_number(a->value.number_value / b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value == b->value.number_value);
    }
    return make_boolean(false);
}

SchemeObject* scheme_less_than(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value < b->value.number_value);
    }
    return make_boolean(false);
}

SchemeObject* scheme_greater_than(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value > b->value.number_value);
    }
    return make_boolean(false);
}

void scheme_display(SchemeObject* obj) {
    if (is_number(obj)) {
        printf("%g", obj->value.number_value);
    } else if (is_boolean(obj)) {
        printf("%s", obj->value.boolean_value ? "#t" : "#f");
    } else if (is_string(obj)) {
        printf("%s", obj->value.string_value);
    } else if (obj && obj->type == SCHEME_SYMBOL) {
        printf("%s", obj->value.symbol_name);
    } else if (is_pair(obj)) {
        scheme_display_list(obj);
    } else if (is_nil(obj)) {
        printf("()");
    } else {
        printf("(...)");
    }
}

void scheme_display_list(SchemeObject* obj) {
    printf("(");
    while (is_pair(obj)) {
        scheme_display(obj->value.pair.car);
        obj = obj->value.pair.cdr;
        if (is_pair(obj)) {
            printf(" ");
        } else if (!is_nil(obj)) {
            printf(" . ");
            scheme_display(obj);
        }
    }
    printf(")");
}

void init_runtime() {
    scheme_nil = malloc(sizeof(SchemeObject));
    scheme_nil->type = SCHEME_NIL;
    
    scheme_true = malloc(sizeof(SchemeObject));
    scheme_true->type = SCHEME_BOOLEAN;
    scheme_true->value.boolean_value = true;
    
    scheme_false = malloc(sizeof(SchemeObject));
    scheme_false->type = SCHEME_BOOLEAN;
    scheme_false->value.boolean_value = false;
}

SchemeObject* scheme_less(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value < b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_greater(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value > b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_less_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value <= b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_greater_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value >= b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_car(SchemeObject* pair) {
    if (is_pair(pair)) {
        return pair->value.pair.car;
    }
    return scheme_nil;
}

SchemeObject* scheme_cdr(SchemeObject* pair) {
    if (is_pair(pair)) {
        return pair->value.pair.cdr;
    }
    return scheme_nil;
}

SchemeObject* scheme_cons(SchemeObject* car, SchemeObject* cdr) {
    return make_pair(car, cdr);
}

SchemeObject* make_compiled_procedure(SchemeObject* (*func)(SchemeObject**, int), int arity, const char* name) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PROCEDURE;
    obj->value.procedure.func = func;
    obj->value.procedure.arity = arity;
    obj->value.procedure.name = malloc(strlen(name) + 1);
    strcpy(obj->value.procedure.name, name);
    obj->value.procedure.parameters = NULL;
    obj->value.procedure.body = NULL;
    obj->value.procedure.closure = NULL;
    return obj;
}

SchemeObject* make_procedure(SchemeObject* params, SchemeObject* body, Environment* env) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PROCEDURE;
    obj->value.procedure.parameters = params;
    obj->value.procedure.body = body;
    obj->value.procedure.closure = env;
    obj->value.procedure.func = NULL; // Interpreted procedure
    obj->value.procedure.arity = 0;
    obj->value.procedure.name = NULL;
    return obj;
}

SchemeObject* scheme_number_p(SchemeObject* obj) {
    return make_boolean(is_number(obj));
}

SchemeObject* scheme_boolean_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_BOOLEAN);
}

SchemeObject* scheme_string_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_STRING);
}

SchemeObject* scheme_symbol_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_SYMBOL);
}

SchemeObject* scheme_pair_p(SchemeObject* obj) {
    return make_boolean(is_pair(obj));
}

SchemeObject* scheme_null_p(SchemeObject* obj) {
    return make_boolean(is_nil(obj));
}

SchemeObject* scheme_procedure_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_PROCEDURE);
}

SchemeObject* scheme_length(SchemeObject* obj) {
    int count = 0;
    while (is_pair(obj)) {
        count++;
        obj = obj->value.pair.cdr;
    }
    return make_number(count);
}

SchemeObject* scheme_string_length(SchemeObject* obj) {
    if (obj && obj->type == SCHEME_STRING) {
        return make_number(strlen(obj->value.string_value));
    }
    return scheme_nil;
}

SchemeObject* scheme_string_ref(SchemeObject* str, SchemeObject* index) {
    if (str && str->type == SCHEME_STRING && is_number(index)) {
        int idx = (int)index->value.number_value;
        int len = strlen(str->value.string_value);
        if (idx >= 0 && idx < len) {
            char result[2];
            result[0] = str->value.string_value[idx];
            result[1] = 0;
            return make_string(result);
        }
    }
    return scheme_nil;
}

SchemeObject* lookup_variable(const char* name) {
    for (int i = 0; i < var_count; i++) {
        if (strcmp(var_names[i], name) == 0) {
            return var_values[i];
        }
    }
    return make_symbol(name); // Return symbol if not found
}

void define_variable(const char* name, SchemeObject* value) {
    // Check if variable already exists
    for (int i = 0; i < var_count; i++) {
        if (strcmp(var_names[i], name) == 0) {
            var_values[i] = value;
            return;
        }
    }
    // Add new variable
    if (var_count < MAX_VARS) {
        var_names[var_count] = malloc(strlen(name) + 1);
        strcpy(var_names[var_count], name);
        var_values[var_count] = value;
        var_count++;
    }
}

// DEBUG: About to emit lambda functions
// DEBUG: Attempting to emit lambda functions
// DEBUG: No lambda functions found in context
// DEBUG: Finished emitting lambda functions
int main() {
    init_runtime();
    SchemeObject* result;

// Display
SchemeObject* temp_0;
result = make_string("Testing quoted list compilation:");
temp_0 = result;
scheme_display(temp_0);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_1;
// Quote
// Building simple quoted list
{
    SchemeObject* elements[4];
    elements[0] = make_number(1);
    elements[1] = make_number(2);
    elements[2] = make_number(3);
    elements[3] = make_number(4);
    result = scheme_nil;
    result = make_pair(elements[3], result);
    result = make_pair(elements[2], result);
    result = make_pair(elements[1], result);
    result = make_pair(elements[0], result);
}
temp_1 = result;
scheme_display(temp_1);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_2;
result = make_string("Done");
temp_2 = result;
scheme_display(temp_2);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

    return 0;
}
