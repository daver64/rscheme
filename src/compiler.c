#include "rscheme.h"
#include <stdarg.h>

// Forward declarations
void compile_lambda_if_expression(SchemeObject* if_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size);
void compile_lambda_arithmetic(SchemeObject* arith_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size, const char* function_name);
void compile_lambda_function_call(SchemeObject* call_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size);
void compile_lambda_expression(SchemeObject* expr, SchemeObject* params, char* lambda_code, int* offset, int max_size, const char* result_var);
void compile_define(SchemeObject* operands, CompilerContext* ctx);
void compile_quoted_expression(SchemeObject* expr, CompilerContext* ctx);
bool is_simple_list(SchemeObject* expr);
void compile_simple_quoted_list(SchemeObject* list_expr, CompilerContext* ctx);
void compile_quoted_value_to_variable(SchemeObject* expr, CompilerContext* ctx, int temp_var, const char* var_name);

CompilerContext* create_compiler_context(FILE* output, Environment* env, bool optimize) {
    CompilerContext* ctx = (CompilerContext*)scheme_malloc(sizeof(CompilerContext));
    ctx->output = output;
    ctx->env = env;
    ctx->indent_level = 0;
    ctx->temp_var_counter = 0;
    ctx->label_counter = 0;
    ctx->function_counter = 0;
    ctx->optimize = optimize;
    ctx->current_function = NULL;
    ctx->lambda_functions = NULL;
    ctx->lambda_output = NULL;
    return ctx;
}

void destroy_compiler_context(CompilerContext* ctx) {
    if (ctx) {
        if (ctx->current_function) {
            scheme_free(ctx->current_function);
        }
        scheme_free(ctx);
    }
}

void emit_indent(CompilerContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

void emit_line(CompilerContext* ctx, const char* format, ...) {
    va_list args;
    va_start(args, format);
    emit_indent(ctx);
    vfprintf(ctx->output, format, args);
    fprintf(ctx->output, "\n");
    va_end(args);
}

void emit_comment(CompilerContext* ctx, const char* comment) {
    emit_line(ctx, "// %s", comment);
}

char* generate_temp_var(CompilerContext* ctx) {
    char* var = scheme_malloc(32);
    snprintf(var, 32, "temp_%d", ctx->temp_var_counter++);
    return var;
}

char* generate_label(CompilerContext* ctx) {
    char* label = scheme_malloc(32);
    snprintf(label, 32, "label_%d", ctx->label_counter++);
    return label;
}

char* generate_function_name(CompilerContext* ctx) {
    char* name = scheme_malloc(32);
    snprintf(name, 32, "lambda_func_%d", ctx->function_counter++);
    return name;
}

void generate_c_header(CompilerContext* ctx) {
    fprintf(ctx->output, "// Generated by RScheme compiler\n");
    fprintf(ctx->output, "#include <stdio.h>\n");
    fprintf(ctx->output, "#include <stdlib.h>\n");
    fprintf(ctx->output, "#include <string.h>\n");
    fprintf(ctx->output, "#include <stdbool.h>\n");
    fprintf(ctx->output, "#include <math.h>\n\n");
    
    fprintf(ctx->output, "// Forward declarations\n");
    fprintf(ctx->output, "typedef struct Environment Environment;\n\n");
    
    fprintf(ctx->output, "// Scheme object types\n");
    fprintf(ctx->output, "typedef enum {\n");
    fprintf(ctx->output, "    SCHEME_NIL, SCHEME_BOOLEAN, SCHEME_NUMBER,\n");
    fprintf(ctx->output, "    SCHEME_SYMBOL, SCHEME_STRING, SCHEME_PAIR,\n");
    fprintf(ctx->output, "    SCHEME_PROCEDURE, SCHEME_PRIMITIVE\n");
    fprintf(ctx->output, "} SchemeType;\n\n");
    
    fprintf(ctx->output, "typedef struct SchemeObject {\n");
    fprintf(ctx->output, "    SchemeType type;\n");
    fprintf(ctx->output, "    union {\n");
    fprintf(ctx->output, "        bool boolean_value;\n");
    fprintf(ctx->output, "        double number_value;\n");
    fprintf(ctx->output, "        char* string_value;\n");
    fprintf(ctx->output, "        char* symbol_name;\n");
    fprintf(ctx->output, "        struct { struct SchemeObject* car; struct SchemeObject* cdr; } pair;\n");
    fprintf(ctx->output, "        struct {\n");
    fprintf(ctx->output, "            struct SchemeObject* parameters;  // List of parameter symbols (for interpreted)\n");
    fprintf(ctx->output, "            struct SchemeObject* body;        // List of expressions (for interpreted)\n");
    fprintf(ctx->output, "            Environment* closure;             // Captured environment (for interpreted)\n");
    fprintf(ctx->output, "            struct SchemeObject* (*func)(struct SchemeObject**, int); // Function pointer (for compiled)\n");
    fprintf(ctx->output, "            int arity;                        // Number of parameters\n");
    fprintf(ctx->output, "            char* name;                       // Function name (for debugging)\n");
    fprintf(ctx->output, "        } procedure;\n");
    fprintf(ctx->output, "    } value;\n");
    fprintf(ctx->output, "} SchemeObject;\n\n");
    
    fprintf(ctx->output, "// Runtime functions\n");
    fprintf(ctx->output, "SchemeObject* scheme_nil;\n");
    fprintf(ctx->output, "SchemeObject* scheme_true;\n");
    fprintf(ctx->output, "SchemeObject* scheme_false;\n\n");
    
    fprintf(ctx->output, "// Function declarations\n");
    fprintf(ctx->output, "void scheme_display(SchemeObject* obj);\n");
    fprintf(ctx->output, "void scheme_display_list(SchemeObject* obj);\n");
    fprintf(ctx->output, "SchemeObject* lookup_variable(const char* name);\n");
    fprintf(ctx->output, "void define_variable(const char* name, SchemeObject* value);\n\n");
    
    fprintf(ctx->output, "// Global variables (simple implementation)\n");
    fprintf(ctx->output, "#define MAX_VARS 100\n");
    fprintf(ctx->output, "char* var_names[MAX_VARS];\n");
    fprintf(ctx->output, "SchemeObject* var_values[MAX_VARS];\n");
    fprintf(ctx->output, "int var_count = 0;\n\n");
    
    generate_runtime_functions(ctx);
}

void generate_runtime_functions(CompilerContext* ctx) {
    fprintf(ctx->output, "// Runtime functions\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_nil;\n");
    fprintf(ctx->output, "SchemeObject* scheme_true;\n");
    fprintf(ctx->output, "SchemeObject* scheme_false;\n\n");
    
    // Object creation functions
    fprintf(ctx->output, "SchemeObject* make_number(double value) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_NUMBER;\n");
    fprintf(ctx->output, "    obj->value.number_value = value;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_boolean(bool value) {\n");
    fprintf(ctx->output, "    return value ? scheme_true : scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_string(const char* value) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_STRING;\n");
    fprintf(ctx->output, "    obj->value.string_value = malloc(strlen(value) + 1);\n");
    fprintf(ctx->output, "    strcpy(obj->value.string_value, value);\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_symbol(const char* name) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_SYMBOL;\n");
    fprintf(ctx->output, "    obj->value.symbol_name = malloc(strlen(name) + 1);\n");
    fprintf(ctx->output, "    strcpy(obj->value.symbol_name, name);\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_pair(SchemeObject* car, SchemeObject* cdr) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_PAIR;\n");
    fprintf(ctx->output, "    obj->value.pair.car = car;\n");
    fprintf(ctx->output, "    obj->value.pair.cdr = cdr;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Type predicates
    fprintf(ctx->output, "bool is_true(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj != scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_number(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_NUMBER;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_boolean(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_string(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_STRING;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_pair(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_PAIR;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_nil(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj == scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_procedure(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_PROCEDURE;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_symbol(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_SYMBOL;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* call_procedure(SchemeObject* proc, SchemeObject** args, int argc) {\n");
    fprintf(ctx->output, "    if (!proc || !is_procedure(proc)) {\n");
    fprintf(ctx->output, "        return scheme_nil;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    // Check if it's a compiled procedure (has func pointer)\n");
    fprintf(ctx->output, "    if (proc->value.procedure.func) {\n");
    fprintf(ctx->output, "        return proc->value.procedure.func(args, argc);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    // For interpreted procedures, we can't handle them in compiled code\n");
    fprintf(ctx->output, "    // This would require a full interpreter runtime\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // List operations
    fprintf(ctx->output, "SchemeObject* car(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_pair(obj)) return obj->value.pair.car;\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* cdr(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_pair(obj)) return obj->value.pair.cdr;\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Arithmetic operations
    fprintf(ctx->output, "SchemeObject* scheme_add(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value + b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_subtract(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value - b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_multiply(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value * b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_divide(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b) && b->value.number_value != 0) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value / b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Comparison operations
    fprintf(ctx->output, "SchemeObject* scheme_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value == b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_less_than(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value < b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater_than(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value > b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    // Display function
    fprintf(ctx->output, "void scheme_display(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_number(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%g\", obj->value.number_value);\n");
    fprintf(ctx->output, "    } else if (is_boolean(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%s\", obj->value.boolean_value ? \"#t\" : \"#f\");\n");
    fprintf(ctx->output, "    } else if (is_string(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%s\", obj->value.string_value);\n");
    fprintf(ctx->output, "    } else if (obj && obj->type == SCHEME_SYMBOL) {\n");
    fprintf(ctx->output, "        printf(\"%%s\", obj->value.symbol_name);\n");
    fprintf(ctx->output, "    } else if (is_pair(obj)) {\n");
    fprintf(ctx->output, "        scheme_display_list(obj);\n");
    fprintf(ctx->output, "    } else if (is_nil(obj)) {\n");
    fprintf(ctx->output, "        printf(\"()\");\n");
    fprintf(ctx->output, "    } else {\n");
    fprintf(ctx->output, "        printf(\"(...)\");\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "void scheme_display_list(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    printf(\"(\");\n");
    fprintf(ctx->output, "    while (is_pair(obj)) {\n");
    fprintf(ctx->output, "        scheme_display(obj->value.pair.car);\n");
    fprintf(ctx->output, "        obj = obj->value.pair.cdr;\n");
    fprintf(ctx->output, "        if (is_pair(obj)) {\n");
    fprintf(ctx->output, "            printf(\" \");\n");
    fprintf(ctx->output, "        } else if (!is_nil(obj)) {\n");
    fprintf(ctx->output, "            printf(\" . \");\n");
    fprintf(ctx->output, "            scheme_display(obj);\n");
    fprintf(ctx->output, "        }\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    printf(\")\");\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "void init_runtime() {\n");
    fprintf(ctx->output, "    scheme_nil = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_nil->type = SCHEME_NIL;\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    scheme_true = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_true->type = SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "    scheme_true->value.boolean_value = true;\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    scheme_false = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_false->type = SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "    scheme_false->value.boolean_value = false;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Additional runtime functions
    fprintf(ctx->output, "SchemeObject* scheme_less(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value < b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value > b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_less_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value <= b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value >= b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_car(SchemeObject* pair) {\n");
    fprintf(ctx->output, "    if (is_pair(pair)) {\n");
    fprintf(ctx->output, "        return pair->value.pair.car;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_cdr(SchemeObject* pair) {\n");
    fprintf(ctx->output, "    if (is_pair(pair)) {\n");
    fprintf(ctx->output, "        return pair->value.pair.cdr;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_cons(SchemeObject* car, SchemeObject* cdr) {\n");
    fprintf(ctx->output, "    return make_pair(car, cdr);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_compiled_procedure(SchemeObject* (*func)(SchemeObject**, int), int arity, const char* name) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_PROCEDURE;\n");
    fprintf(ctx->output, "    obj->value.procedure.func = func;\n");
    fprintf(ctx->output, "    obj->value.procedure.arity = arity;\n");
    fprintf(ctx->output, "    obj->value.procedure.name = malloc(strlen(name) + 1);\n");
    fprintf(ctx->output, "    strcpy(obj->value.procedure.name, name);\n");
    fprintf(ctx->output, "    obj->value.procedure.parameters = NULL;\n");
    fprintf(ctx->output, "    obj->value.procedure.body = NULL;\n");
    fprintf(ctx->output, "    obj->value.procedure.closure = NULL;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Also generate the original make_procedure for interpreted lambdas
    fprintf(ctx->output, "SchemeObject* make_procedure(SchemeObject* params, SchemeObject* body, Environment* env) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_PROCEDURE;\n");
    fprintf(ctx->output, "    obj->value.procedure.parameters = params;\n");
    fprintf(ctx->output, "    obj->value.procedure.body = body;\n");
    fprintf(ctx->output, "    obj->value.procedure.closure = env;\n");
    fprintf(ctx->output, "    obj->value.procedure.func = NULL; // Interpreted procedure\n");
    fprintf(ctx->output, "    obj->value.procedure.arity = 0;\n");
    fprintf(ctx->output, "    obj->value.procedure.name = NULL;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_number_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_number(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_boolean_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_BOOLEAN);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_string_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_STRING);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_symbol_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_SYMBOL);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_pair_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_pair(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_null_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_nil(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_procedure_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_PROCEDURE);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_length(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    int count = 0;\n");
    fprintf(ctx->output, "    while (is_pair(obj)) {\n");
    fprintf(ctx->output, "        count++;\n");
    fprintf(ctx->output, "        obj = obj->value.pair.cdr;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_number(count);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_string_length(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (obj && obj->type == SCHEME_STRING) {\n");
    fprintf(ctx->output, "        return make_number(strlen(obj->value.string_value));\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_string_ref(SchemeObject* str, SchemeObject* index) {\n");
    fprintf(ctx->output, "    if (str && str->type == SCHEME_STRING && is_number(index)) {\n");
    fprintf(ctx->output, "        int idx = (int)index->value.number_value;\n");
    fprintf(ctx->output, "        int len = strlen(str->value.string_value);\n");
    fprintf(ctx->output, "        if (idx >= 0 && idx < len) {\n");
    fprintf(ctx->output, "            char result[2];\n");
    fprintf(ctx->output, "            result[0] = str->value.string_value[idx];\n");
    fprintf(ctx->output, "            result[1] = 0;\n");
    fprintf(ctx->output, "            return make_string(result);\n");
    fprintf(ctx->output, "        }\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* lookup_variable(const char* name) {\n");
    fprintf(ctx->output, "    for (int i = 0; i < var_count; i++) {\n");
    fprintf(ctx->output, "        if (strcmp(var_names[i], name) == 0) {\n");
    fprintf(ctx->output, "            return var_values[i];\n");
    fprintf(ctx->output, "        }\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_symbol(name); // Return symbol if not found\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "void define_variable(const char* name, SchemeObject* value) {\n");
    fprintf(ctx->output, "    // Check if variable already exists\n");
    fprintf(ctx->output, "    for (int i = 0; i < var_count; i++) {\n");
    fprintf(ctx->output, "        if (strcmp(var_names[i], name) == 0) {\n");
    fprintf(ctx->output, "            var_values[i] = value;\n");
    fprintf(ctx->output, "            return;\n");
    fprintf(ctx->output, "        }\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    // Add new variable\n");
    fprintf(ctx->output, "    if (var_count < MAX_VARS) {\n");
    fprintf(ctx->output, "        var_names[var_count] = malloc(strlen(name) + 1);\n");
    fprintf(ctx->output, "        strcpy(var_names[var_count], name);\n");
    fprintf(ctx->output, "        var_values[var_count] = value;\n");
    fprintf(ctx->output, "        var_count++;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "}\n\n");
}

void generate_main_function(CompilerContext* ctx, SchemeObject* expr) {
    fprintf(ctx->output, "int main() {\n");
    ctx->indent_level++;
    
    emit_line(ctx, "init_runtime();");
    emit_line(ctx, "SchemeObject* result;");
    emit_line(ctx, "");
    
    compile_expression(expr, ctx);
    
    emit_line(ctx, "");
    emit_line(ctx, "return 0;");
    
    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

void compile_expression(SchemeObject* expr, CompilerContext* ctx) {
    if (!expr) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    switch (expr->type) {
        case SCHEME_NIL:
            emit_line(ctx, "result = scheme_nil;");
            break;
            
        case SCHEME_BOOLEAN:
            emit_line(ctx, "result = make_boolean(%s);", 
                     expr->value.boolean_value ? "true" : "false");
            break;
            
        case SCHEME_NUMBER:
            emit_line(ctx, "result = make_number(%.6g);", expr->value.number_value);
            break;
            
        case SCHEME_SYMBOL:
            // Look up variable, or return symbol if not found
            emit_line(ctx, "result = lookup_variable(\"%s\");", expr->value.symbol_name);
            break;
            
        case SCHEME_STRING:
            emit_line(ctx, "result = make_string(\"%s\");", expr->value.string_value);
            break;
            
        case SCHEME_PAIR:
            compile_application(expr, ctx);
            break;
            
        default:
            emit_line(ctx, "result = scheme_nil; // Unknown expression type");
            break;
    }
}

void compile_application(SchemeObject* expr, CompilerContext* ctx) {
    SchemeObject* operator = car(expr);
    SchemeObject* operands = cdr(expr);
    
    if (is_symbol(operator)) {
        const char* name = operator->value.symbol_name;
        
        // Special forms
        if (strcmp(name, "if") == 0) {
            compile_if(operands, ctx);
            return;
        } else if (strcmp(name, "define") == 0) {
            compile_define(operands, ctx);
            return;
        } else if (strcmp(name, "lambda") == 0) {
            compile_lambda(operands, ctx);
            return;
        } else if (strcmp(name, "set!") == 0) {
            compile_set(operands, ctx);
            return;
        } else if (strcmp(name, "begin") == 0) {
            compile_begin(operands, ctx);
            return;
        } else if (strcmp(name, "quote") == 0) {
            compile_quote(operands, ctx);
            return;
        }
        
        // Built-in procedures
        if (strcmp(name, "display") == 0) {
            emit_comment(ctx, "Display");
            if (operands && is_pair(operands)) {
                char* temp = generate_temp_var(ctx);
                emit_line(ctx, "SchemeObject* %s;", temp);
                compile_expression(car(operands), ctx);
                emit_line(ctx, "%s = result;", temp);
                emit_line(ctx, "scheme_display(%s);", temp);
                emit_line(ctx, "result = scheme_nil;");
                scheme_free(temp);
            } else {
                emit_line(ctx, "result = scheme_nil;");
            }
            return;
        } else if (strcmp(name, "newline") == 0) {
            emit_comment(ctx, "Newline");
            emit_line(ctx, "printf(\"\\n\");");
            emit_line(ctx, "result = scheme_nil;");
            return;
        } else if (strcmp(name, "+") == 0) {
            compile_arithmetic(operands, ctx, "add");
            return;
        } else if (strcmp(name, "-") == 0) {
            compile_arithmetic(operands, ctx, "subtract");
            return;
        } else if (strcmp(name, "*") == 0) {
            compile_arithmetic(operands, ctx, "multiply");
            return;
        } else if (strcmp(name, "/") == 0) {
            compile_arithmetic(operands, ctx, "divide");
            return;
        } else if (strcmp(name, "=") == 0) {
            compile_comparison(operands, ctx, "equal");
            return;
        } else if (strcmp(name, "<") == 0) {
            compile_comparison(operands, ctx, "less");
            return;
        } else if (strcmp(name, ">") == 0) {
            compile_comparison(operands, ctx, "greater");
            return;
        } else if (strcmp(name, "<=") == 0) {
            compile_comparison(operands, ctx, "less_equal");
            return;
        } else if (strcmp(name, ">=") == 0) {
            compile_comparison(operands, ctx, "greater_equal");
            return;
        } else if (strcmp(name, "cons") == 0) {
            compile_cons(operands, ctx);
            return;
        } else if (strcmp(name, "car") == 0) {
            compile_car_cdr(operands, ctx, "car");
            return;
        } else if (strcmp(name, "cdr") == 0) {
            compile_car_cdr(operands, ctx, "cdr");
            return;
        } else if (strcmp(name, "number?") == 0) {
            compile_type_predicate(operands, ctx, "number_p");
            return;
        } else if (strcmp(name, "boolean?") == 0) {
            compile_type_predicate(operands, ctx, "boolean_p");
            return;
        } else if (strcmp(name, "string?") == 0) {
            compile_type_predicate(operands, ctx, "string_p");
            return;
        } else if (strcmp(name, "symbol?") == 0) {
            compile_type_predicate(operands, ctx, "symbol_p");
            return;
        } else if (strcmp(name, "pair?") == 0) {
            compile_type_predicate(operands, ctx, "pair_p");
            return;
        } else if (strcmp(name, "null?") == 0) {
            compile_type_predicate(operands, ctx, "null_p");
            return;
        } else if (strcmp(name, "procedure?") == 0) {
            compile_type_predicate(operands, ctx, "procedure_p");
            return;
        } else if (strcmp(name, "list") == 0) {
            compile_list(operands, ctx);
            return;
        } else if (strcmp(name, "length") == 0) {
            compile_single_arg_builtin(operands, ctx, "length");
            return;
        } else if (strcmp(name, "string-length") == 0) {
            compile_single_arg_builtin(operands, ctx, "string_length");
            return;
        } else if (strcmp(name, "string-ref") == 0) {
            compile_two_arg_builtin(operands, ctx, "string_ref");
            return;
        }
    }
    
    // Handle procedure calls - check if the operator is a variable that might be a procedure
    emit_comment(ctx, "Procedure call");
    
    char* proc_temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", proc_temp);
    
    // Evaluate the operator (should be a procedure)
    compile_expression(operator, ctx);
    emit_line(ctx, "%s = result;", proc_temp);
    
    // Check if it's a procedure and call it
    emit_line(ctx, "if (%s && %s->type == SCHEME_PROCEDURE) {", proc_temp, proc_temp);
    
    // Count arguments
    int arg_count = 0;
    SchemeObject* current = operands;
    while (current && is_pair(current)) {
        arg_count++;
        current = cdr(current);
    }
    
    if (arg_count > 0) {
        // Create argument array
        emit_line(ctx, "    SchemeObject* proc_args[%d];", arg_count);
        
        // Evaluate arguments
        current = operands;
        for (int i = 0; i < arg_count; i++) {
            char* arg_temp = generate_temp_var(ctx);
            emit_line(ctx, "    SchemeObject* %s;", arg_temp);
            compile_expression(car(current), ctx);
            emit_line(ctx, "    %s = result;", arg_temp);
            emit_line(ctx, "    proc_args[%d] = %s;", i, arg_temp);
            scheme_free(arg_temp);
            current = cdr(current);
        }
        
        // Call the procedure
        emit_line(ctx, "    result = %s->value.procedure.func(proc_args, %d);", proc_temp, arg_count);
    } else {
        // Zero arguments
        emit_line(ctx, "    result = %s->value.procedure.func(NULL, 0);", proc_temp);
    }
    
    emit_line(ctx, "} else {");
    emit_line(ctx, "    result = scheme_nil; // Not a procedure");
    emit_line(ctx, "}");
    
    scheme_free(proc_temp);
}

void compile_if(SchemeObject* args, CompilerContext* ctx) {
    if (!args || !is_pair(args)) {
        emit_line(ctx, "result = scheme_nil; // Invalid if expression");
        return;
    }
    
    SchemeObject* test = car(args);
    args = cdr(args);
    
    if (!args || !is_pair(args)) {
        emit_line(ctx, "result = scheme_nil; // Invalid if expression");
        return;
    }
    
    SchemeObject* then_expr = car(args);
    args = cdr(args);
    SchemeObject* else_expr = (args && is_pair(args)) ? car(args) : SCHEME_NIL_OBJECT;
    
    char* temp_var = generate_temp_var(ctx);
    char* else_label = generate_label(ctx);
    char* end_label = generate_label(ctx);
    
    emit_comment(ctx, "if expression");
    emit_line(ctx, "SchemeObject* %s;", temp_var);
    
    // Compile test
    compile_expression(test, ctx);
    emit_line(ctx, "%s = result;", temp_var);
    
    emit_line(ctx, "if (!is_true(%s)) goto %s;", temp_var, else_label);
    
    // Then branch
    compile_expression(then_expr, ctx);
    emit_line(ctx, "goto %s;", end_label);
    
    // Else branch
    emit_line(ctx, "%s:", else_label);
    compile_expression(else_expr, ctx);
    
    emit_line(ctx, "%s:", end_label);
    
    scheme_free(temp_var);
    scheme_free(else_label);
    scheme_free(end_label);
}

bool compile_to_c(SchemeObject* expr, const char* output_file, bool optimize) {
    FILE* output = fopen(output_file, "w");
    if (!output) {
        runtime_error("Cannot open output file: %s", output_file);
        return false;
    }
    
    CompilerContext* ctx = create_compiler_context(output, NULL, optimize);
    
    generate_c_header(ctx);
    
    // First pass: compile everything and collect lambda functions  
    FILE* temp_main = tmpfile();
    FILE* orig_output = ctx->output;
    ctx->output = temp_main;
    
    generate_main_function(ctx, expr);
    
    // Now emit lambda functions to the actual output
    ctx->output = orig_output;
    fprintf(ctx->output, "// DEBUG: About to emit lambda functions\n");
    emit_lambda_functions(ctx);
    fprintf(ctx->output, "// DEBUG: Finished emitting lambda functions\n");
    
    // Then emit the main function
    rewind(temp_main);
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), temp_main)) {
        fputs(buffer, ctx->output);
    }
    fclose(temp_main);
    
    destroy_compiler_context(ctx);
    fclose(output);
    
    return true;
}

bool compile_file(const char* input_file, const char* output_file, bool optimize) {
    FILE* input = fopen(input_file, "rb");  // Use binary mode like the interpreter
    if (!input) {
        runtime_error("Cannot open input file: %s", input_file);
        return false;
    }
    
    // Read entire file
    fseek(input, 0, SEEK_END);
    long length = ftell(input);
    fseek(input, 0, SEEK_SET);
    
    char* content = (char*)scheme_malloc(length + 1);
    fread(content, 1, length, input);
    content[length] = '\0';
    fclose(input);
    
    // Parse all expressions
    Parser* parser = create_parser(content);
    
    FILE* output = fopen(output_file, "w");
    if (!output) {
        runtime_error("Cannot open output file: %s", output_file);
        scheme_free(content);
        destroy_parser(parser);
        return false;
    }
    
    CompilerContext* ctx = create_compiler_context(output, NULL, optimize);
    
    generate_c_header(ctx);
    
    // First pass: compile everything and collect lambda functions  
    FILE* temp_main = tmpfile();
    FILE* orig_output = ctx->output;
    ctx->output = temp_main;
    
    // Generate main function start
    fprintf(ctx->output, "int main() {\n");
    fprintf(ctx->output, "    init_runtime();\n");
    fprintf(ctx->output, "    SchemeObject* result;\n\n");
    
    // Compile all expressions in sequence
    bool success = true;
    while (true) {
        SchemeObject* expr = parse_expression(parser);
        
        if (has_parse_error(parser)) {
            print_parse_error(parser, stderr);
            success = false;
            break;
        }
        
        if (!expr) {
            break; // End of input
        }
        
        compile_expression(expr, ctx);
        fprintf(ctx->output, "\n");
    }
    
    // Generate main function end
    fprintf(ctx->output, "    return 0;\n");
    fprintf(ctx->output, "}\n");
    
    // Now emit lambda functions to the actual output
    ctx->output = orig_output;
    fprintf(ctx->output, "// DEBUG: About to emit lambda functions\n");
    emit_lambda_functions(ctx);
    fprintf(ctx->output, "// DEBUG: Finished emitting lambda functions\n");
    
    // Then emit the main function
    rewind(temp_main);
    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), temp_main)) {
        fputs(buffer, ctx->output);
    }
    fclose(temp_main);
    
    destroy_compiler_context(ctx);
    fclose(output);
    destroy_parser(parser);
    scheme_free(content);
    
    return success;
}

void compile_arithmetic(SchemeObject* operands, CompilerContext* ctx, const char* op) {
    emit_comment(ctx, "Arithmetic operation");
    
    if (!operands || is_nil(operands)) {
        // Empty operation - for + and * return identity
        if (strcmp(op, "add") == 0 || strcmp(op, "multiply") == 0) {
            emit_line(ctx, "result = make_number(%s);", 
                     strcmp(op, "add") == 0 ? "0" : "1");
        } else {
            emit_line(ctx, "result = scheme_nil; // Invalid empty operation");
        }
        return;
    }
    
    // Compile first operand
    char* temp1 = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp1);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    operands = cdr(operands);
    
    if (!operands || is_nil(operands)) {
        // Single operand - for - and / this is negation/reciprocal
        if (strcmp(op, "subtract") == 0) {
            emit_line(ctx, "result = make_number(-%s->value.number_value);", temp1);
        } else if (strcmp(op, "divide") == 0) {
            emit_line(ctx, "result = make_number(1.0 / %s->value.number_value);", temp1);
        } else {
            emit_line(ctx, "result = %s;", temp1);
        }
    } else {
        // Multiple operands
        while (operands && !is_nil(operands)) {
            char* temp2 = generate_temp_var(ctx);
            emit_line(ctx, "SchemeObject* %s;", temp2);
            compile_expression(car(operands), ctx);
            emit_line(ctx, "%s = result;", temp2);
            emit_line(ctx, "%s = scheme_%s(%s, %s);", temp1, op, temp1, temp2);
            scheme_free(temp2);
            operands = cdr(operands);
        }
        emit_line(ctx, "result = %s;", temp1);
    }
    
    scheme_free(temp1);
}

void compile_comparison(SchemeObject* operands, CompilerContext* ctx, const char* op) {
    emit_comment(ctx, "Comparison operation");
    
    if (!operands || is_nil(operands) || !cdr(operands) || is_nil(cdr(operands))) {
        emit_line(ctx, "result = make_boolean(true); // Vacuous truth");
        return;
    }
    
    char* done_label = generate_label(ctx);
    char* temp1 = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp1);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    operands = cdr(operands);
    
    while (operands && !is_nil(operands)) {
        char* temp2 = generate_temp_var(ctx);
        emit_line(ctx, "SchemeObject* %s;", temp2);
        compile_expression(car(operands), ctx);
        emit_line(ctx, "%s = result;", temp2);
        emit_line(ctx, "if (!is_true(scheme_%s(%s, %s))) {", op, temp1, temp2);
        emit_line(ctx, "    result = make_boolean(false);");
        emit_line(ctx, "    goto %s;", done_label);
        emit_line(ctx, "}");
        emit_line(ctx, "%s = %s;", temp1, temp2);
        scheme_free(temp2);
        operands = cdr(operands);
    }
    
    emit_line(ctx, "result = make_boolean(true);");
    emit_line(ctx, "%s:;", done_label);
    scheme_free(temp1);
    scheme_free(done_label);
}

void compile_cons(SchemeObject* operands, CompilerContext* ctx) {
    emit_comment(ctx, "Cons operation");
    
    if (!operands || is_nil(operands) || !cdr(operands) || is_nil(cdr(operands))) {
        emit_line(ctx, "result = scheme_nil; // Invalid cons");
        return;
    }
    
    char* temp1 = generate_temp_var(ctx);
    char* temp2 = generate_temp_var(ctx);
    
    emit_line(ctx, "SchemeObject* %s;", temp1);
    emit_line(ctx, "SchemeObject* %s;", temp2);
    
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    compile_expression(car(cdr(operands)), ctx);
    emit_line(ctx, "%s = result;", temp2);
    
    emit_line(ctx, "result = make_pair(%s, %s);", temp1, temp2);
    
    scheme_free(temp1);
    scheme_free(temp2);
}

void compile_car_cdr(SchemeObject* operands, CompilerContext* ctx, const char* operation) {
    emit_comment(ctx, operation);
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil; // Invalid %s", operation);
        return;
    }
    
    char* temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp);
    emit_line(ctx, "result = scheme_%s(%s);", operation, temp);
    scheme_free(temp);
}

void compile_type_predicate(SchemeObject* operands, CompilerContext* ctx, const char* predicate) {
    emit_comment(ctx, predicate);
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_false; // Invalid predicate");
        return;
    }
    
    char* temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp);
    emit_line(ctx, "result = scheme_%s(%s);", predicate, temp);
    scheme_free(temp);
}

void compile_list(SchemeObject* operands, CompilerContext* ctx) {
    emit_comment(ctx, "List construction");
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    // Build the list from right to left
    emit_line(ctx, "result = scheme_nil;");
    
    // Count elements and compile them in reverse order
    int count = 0;
    SchemeObject* current = operands;
    while (current && is_pair(current)) {
        count++;
        current = cdr(current);
    }
    
    // Create temporary variables for each element
    for (int i = 0; i < count; i++) {
        char* temp = generate_temp_var(ctx);
        emit_line(ctx, "SchemeObject* %s;", temp);
    }
    
    // Compile expressions in forward order
    current = operands;
    for (int i = 0; i < count; i++) {
        char temp_name[32];
        snprintf(temp_name, 32, "temp_%d", ctx->temp_var_counter - count + i);
        compile_expression(car(current), ctx);
        emit_line(ctx, "%s = result;", temp_name);
        current = cdr(current);
    }
    
    // Build list from right to left
    emit_line(ctx, "result = scheme_nil;");
    for (int i = count - 1; i >= 0; i--) {
        char temp_name[32];
        snprintf(temp_name, 32, "temp_%d", ctx->temp_var_counter - count + i);
        emit_line(ctx, "result = scheme_cons(%s, result);", temp_name);
    }
}

void compile_single_arg_builtin(SchemeObject* operands, CompilerContext* ctx, const char* function) {
    emit_comment(ctx, function);
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil; // Invalid %s", function);
        return;
    }
    
    char* temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp);
    emit_line(ctx, "result = scheme_%s(%s);", function, temp);
    scheme_free(temp);
}

void compile_two_arg_builtin(SchemeObject* operands, CompilerContext* ctx, const char* function) {
    emit_comment(ctx, function);
    
    if (!operands || is_nil(operands) || !cdr(operands) || is_nil(cdr(operands))) {
        emit_line(ctx, "result = scheme_nil; // Invalid %s", function);
        return;
    }
    
    char* temp1 = generate_temp_var(ctx);
    char* temp2 = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp1);
    emit_line(ctx, "SchemeObject* %s;", temp2);
    
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    compile_expression(car(cdr(operands)), ctx);
    emit_line(ctx, "%s = result;", temp2);
    
    emit_line(ctx, "result = scheme_%s(%s, %s);", function, temp1, temp2);
    scheme_free(temp1);
    scheme_free(temp2);
}

void compile_quote(SchemeObject* operands, CompilerContext* ctx) {
    emit_comment(ctx, "Quote");
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    SchemeObject* quoted = car(operands);
    compile_quoted_expression(quoted, ctx);
}

void compile_quoted_expression(SchemeObject* expr, CompilerContext* ctx) {
    if (!expr || is_nil(expr)) {
        emit_line(ctx, "result = scheme_nil;");
    } else if (is_number(expr)) {
        emit_line(ctx, "result = make_number(%.6g);", expr->value.number_value);
    } else if (is_boolean(expr)) {
        emit_line(ctx, "result = make_boolean(%s);", expr->value.boolean_value ? "true" : "false");
    } else if (is_string(expr)) {
        emit_line(ctx, "result = make_string(\"%s\");", expr->value.string_value);
    } else if (is_symbol(expr)) {
        emit_line(ctx, "result = make_symbol(\"%s\");", expr->value.symbol_name);
    } else if (is_pair(expr)) {
        // Handle quoted lists - need to construct the list
        // For now, handle simple lists like '(1 2 3 4)
        if (is_simple_list(expr)) {
            compile_simple_quoted_list(expr, ctx);
        } else {
            // Handle general pairs
            emit_line(ctx, "{");
            emit_line(ctx, "    SchemeObject* car_part;");
            emit_line(ctx, "    SchemeObject* cdr_part;");
            
            // Recursively compile car and cdr
            int temp_var = ctx->temp_var_counter++;
            emit_line(ctx, "    // Compile car of pair");
            emit_line(ctx, "    {");
            emit_line(ctx, "        SchemeObject* temp_result_%d;", temp_var);
            
            // We need to compile the car without affecting the main result
            // This is tricky with the current architecture, so let's use a simpler approach
            compile_quoted_value_to_variable(car(expr), ctx, temp_var, "car_part");
            
            emit_line(ctx, "    }");
            
            temp_var = ctx->temp_var_counter++;
            emit_line(ctx, "    // Compile cdr of pair");
            emit_line(ctx, "    {");
            compile_quoted_value_to_variable(cdr(expr), ctx, temp_var, "cdr_part");
            emit_line(ctx, "    }");
            
            emit_line(ctx, "    result = make_pair(car_part, cdr_part);");
            emit_line(ctx, "}");
        }
    } else {
        emit_line(ctx, "result = scheme_nil; // Unknown quoted type");
    }
}

// Helper function to check if this is a simple list (not nested pairs)
bool is_simple_list(SchemeObject* expr) {
    while (expr && is_pair(expr)) {
        SchemeObject* item = car(expr);
        // If any item is complex (pair), it's not a simple list
        if (is_pair(item)) {
            return false;
        }
        expr = cdr(expr);
    }
    return true; // All items are simple values
}

// Helper function to compile a simple quoted list like '(1 2 3 4)
void compile_simple_quoted_list(SchemeObject* list_expr, CompilerContext* ctx) {
    emit_comment(ctx, "Building simple quoted list");
    
    // Count elements
    int count = 0;
    SchemeObject* temp = list_expr;
    while (temp && is_pair(temp)) {
        count++;
        temp = cdr(temp);
    }
    
    if (count == 0) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    emit_line(ctx, "{");
    
    // Create variables for each element
    emit_line(ctx, "    SchemeObject* elements[%d];", count);
    
    // Compile each element
    temp = list_expr;
    for (int i = 0; i < count; i++) {
        if (temp && is_pair(temp)) {
            SchemeObject* item = car(temp);
            if (is_number(item)) {
                emit_line(ctx, "    elements[%d] = make_number(%.6g);", i, item->value.number_value);
            } else if (is_boolean(item)) {
                emit_line(ctx, "    elements[%d] = make_boolean(%s);", i, item->value.boolean_value ? "true" : "false");
            } else if (is_string(item)) {
                emit_line(ctx, "    elements[%d] = make_string(\"%s\");", i, item->value.string_value);
            } else if (is_symbol(item)) {
                emit_line(ctx, "    elements[%d] = make_symbol(\"%s\");", i, item->value.symbol_name);
            } else {
                emit_line(ctx, "    elements[%d] = scheme_nil;", i);
            }
            temp = cdr(temp);
        }
    }
    
    // Build the list from right to left
    emit_line(ctx, "    result = scheme_nil;");
    for (int i = count - 1; i >= 0; i--) {
        emit_line(ctx, "    result = make_pair(elements[%d], result);", i);
    }
    
    emit_line(ctx, "}");
}

// Helper function to compile a quoted value to a specific variable
void compile_quoted_value_to_variable(SchemeObject* expr, CompilerContext* ctx, int temp_var, const char* var_name) {
    if (!expr || is_nil(expr)) {
        emit_line(ctx, "        %s = scheme_nil;", var_name);
    } else if (is_number(expr)) {
        emit_line(ctx, "        %s = make_number(%.6g);", var_name, expr->value.number_value);
    } else if (is_boolean(expr)) {
        emit_line(ctx, "        %s = make_boolean(%s);", var_name, expr->value.boolean_value ? "true" : "false");
    } else if (is_string(expr)) {
        emit_line(ctx, "        %s = make_string(\"%s\");", var_name, expr->value.string_value);
    } else if (is_symbol(expr)) {
        emit_line(ctx, "        %s = make_symbol(\"%s\");", var_name, expr->value.symbol_name);
    } else {
        emit_line(ctx, "        %s = scheme_nil; // Complex quoted value", var_name);
    }
}

void compile_lambda(SchemeObject* args, CompilerContext* ctx) {
    emit_comment(ctx, "Lambda expression");
    
    if (!args || is_nil(args)) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    // Debug: Add a comment to show lambda compilation is happening
    emit_comment(ctx, "Compiling lambda - collecting function");
    
    // Debug: Add a comment to show lambda compilation is happening
    emit_comment(ctx, "Compiling lambda - collecting function");
    
    // Debug: Show what we're working with
    emit_comment(ctx, "Lambda args structure debugging");
    
    // Actually, let's check if the lambda is structured correctly
    // It should be: (lambda (params) body)
    // So args should be: ((params) body)
    
    if (!is_pair(args)) {
        emit_line(ctx, "result = scheme_nil; // Args not a pair");
        return;
    }
    
    SchemeObject* first = car(args);   // Should be parameter list
    SchemeObject* rest = cdr(args);    // Should be (body ...)
    
    if (!is_pair(rest)) {
        emit_line(ctx, "result = scheme_nil; // No body found");
        return;
    }
    
    SchemeObject* params = first;
    SchemeObject* body = car(rest);  // Extract the actual body
    
    // Debug: Show what we extracted
    char debug_info[512];
    if (is_pair(body)) {
        SchemeObject* body_op = car(body);
        const char* op_str = is_symbol(body_op) ? body_op->value.symbol_name : "not-symbol";
        snprintf(debug_info, sizeof(debug_info), "Extracted body operator: %s", op_str);
        emit_comment(ctx, debug_info);
    }
    
    // Generate unique function name
    char* func_name = generate_function_name(ctx);
    
    // Count parameters
    int arity = 0;
    SchemeObject* current = params;
    while (current && is_pair(current)) {
        arity++;
        current = cdr(current);
    }
    
    // Store the lambda function code for later emission at file scope
    char lambda_code[4096];
    int offset = 0;
    
    // Generate the function declaration
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "// Generated lambda function\n");
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "SchemeObject* %s(SchemeObject** args, int argc) {\n", func_name);
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "    SchemeObject* result;\n");
    
    // Bind parameters to local variables
    if (arity > 0) {
        offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                          "    // Bind parameters locally\n");
        current = params;
        for (int i = 0; i < arity; i++) {
            if (current && is_symbol(car(current))) {
                // Create local variable instead of using global define_variable
                offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                                 "    SchemeObject* local_%s = (argc > %d) ? args[%d] : scheme_nil;\n", 
                                 car(current)->value.symbol_name, i, i);
                current = cdr(current);
            }
        }
    }
    
    // Compile the body
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "    // Function body\n");
    
    // Now we need to properly compile the lambda body using the expression compiler
    // But we need to handle parameter references specially
    
    // Create a simple compilation for the body that uses compile_expression logic
    if (is_number(body)) {
        offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                          "    result = make_number(%.6g);\n", body->value.number_value);
    } else if (is_symbol(body)) {
        // Check if it's a parameter reference
        bool is_param = false;
        SchemeObject* param_check = params;
        while (param_check && is_pair(param_check)) {
            if (is_symbol(car(param_check)) && strcmp(car(param_check)->value.symbol_name, body->value.symbol_name) == 0) {
                offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                                 "    result = local_%s;\n", body->value.symbol_name);
                is_param = true;
                break;
            }
            param_check = cdr(param_check);
        }
        if (!is_param) {
            offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                              "    result = lookup_variable(\"%s\");\n", body->value.symbol_name);
        }
    } else if (is_pair(body)) {
        // This is where we need to handle full expression compilation
        // For now, let's handle the key cases and then expand
        
        SchemeObject* op = car(body);
        if (!op) {
            offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                             "    result = scheme_nil; // Empty operation\n");
        } else if (is_symbol(op)) {
            const char* op_name = op->value.symbol_name;
            
            // Handle if expressions
            if (strcmp(op_name, "if") == 0) {
                compile_lambda_if_expression(body, params, lambda_code, &offset, sizeof(lambda_code));
            }
            // Handle arithmetic operations
            else if (strcmp(op_name, "*") == 0) {
                compile_lambda_arithmetic(body, params, lambda_code, &offset, sizeof(lambda_code), "scheme_multiply");
            }
            else if (strcmp(op_name, "+") == 0) {
                compile_lambda_arithmetic(body, params, lambda_code, &offset, sizeof(lambda_code), "scheme_add");
            }
            else if (strcmp(op_name, "-") == 0) {
                compile_lambda_arithmetic(body, params, lambda_code, &offset, sizeof(lambda_code), "scheme_subtract");
            }
            else if (strcmp(op_name, "/") == 0) {
                compile_lambda_arithmetic(body, params, lambda_code, &offset, sizeof(lambda_code), "scheme_divide");
            }
            // Handle comparison operations
            else if (strcmp(op_name, "=") == 0) {
                compile_lambda_arithmetic(body, params, lambda_code, &offset, sizeof(lambda_code), "scheme_equal");
            }
            // Handle function calls (including user-defined functions)
            else {
                compile_lambda_function_call(body, params, lambda_code, &offset, sizeof(lambda_code));
            }
        } else {
            offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                             "    result = scheme_nil; // Non-symbol operator\n");
        }
    } else {
        offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                          "    result = scheme_nil; // Unknown body type\n");
    }
    
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "    return result;\n");
    offset += snprintf(lambda_code + offset, sizeof(lambda_code) - offset,
                      "}\n\n");
    
    // Store the lambda function for later emission
    LambdaFunction* lambda_func = malloc(sizeof(LambdaFunction));
    lambda_func->name = _strdup(func_name);
    lambda_func->code = _strdup(lambda_code);
    lambda_func->next = ctx->lambda_functions;
    ctx->lambda_functions = lambda_func;
    
    // Debug: emit a comment to confirm collection
    emit_comment(ctx, "Lambda function collected successfully");
    
    // Create procedure object in the current context
    emit_line(ctx, "result = make_compiled_procedure(%s, %d, \"%s\");", func_name, arity, func_name);
    
    scheme_free(func_name);
}

// Helper function to compile if expressions in lambda bodies
void compile_lambda_if_expression(SchemeObject* if_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size) {
    // if_expr is (if condition then_expr else_expr)
    SchemeObject* condition = car(cdr(if_expr));
    SchemeObject* then_expr = car(cdr(cdr(if_expr)));
    SchemeObject* else_expr = car(cdr(cdr(cdr(if_expr))));
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    {\n");
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        SchemeObject* condition_result;\n");
    
    // Compile the condition
    compile_lambda_expression(condition, params, lambda_code, offset, max_size, "condition_result");
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        if (is_true(condition_result)) {\n");
    
    // Compile then expression
    compile_lambda_expression(then_expr, params, lambda_code, offset, max_size, "result");
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        } else {\n");
    
    // Compile else expression
    if (else_expr) {
        compile_lambda_expression(else_expr, params, lambda_code, offset, max_size, "result");
    } else {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "            result = scheme_nil;\n");
    }
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        }\n");
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    }\n");
}

// Helper function to compile arithmetic operations in lambda bodies
void compile_lambda_arithmetic(SchemeObject* arith_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size, const char* function_name) {
    // arith_expr is (op arg1 arg2 ...)
    SchemeObject* arg1 = car(cdr(arith_expr));
    SchemeObject* arg2 = car(cdr(cdr(arith_expr)));
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    {\n");
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        SchemeObject* temp1;\n");
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        SchemeObject* temp2;\n");
    
    // Compile first argument
    compile_lambda_expression(arg1, params, lambda_code, offset, max_size, "temp1");
    
    // Compile second argument
    compile_lambda_expression(arg2, params, lambda_code, offset, max_size, "temp2");
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        result = %s(temp1, temp2);\n", function_name);
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    }\n");
}

// Helper function to compile function calls in lambda bodies
void compile_lambda_function_call(SchemeObject* call_expr, SchemeObject* params, char* lambda_code, int* offset, int max_size) {
    SchemeObject* function = car(call_expr);
    const char* func_name = is_symbol(function) ? function->value.symbol_name : "unknown";
    
    // Count arguments
    int arg_count = 0;
    SchemeObject* temp = cdr(call_expr);
    while (temp && is_pair(temp)) {
        arg_count++;
        temp = cdr(temp);
    }
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    {\n");
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "        SchemeObject* func = lookup_variable(\"%s\");\n", func_name);
    
    if (arg_count > 0) {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        SchemeObject* args_array[%d];\n", arg_count);
        
        // Compile arguments
        temp = cdr(call_expr);
        for (int i = 0; i < arg_count; i++) {
            if (temp && is_pair(temp)) {
                SchemeObject* arg = car(temp);
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        {\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* arg_temp;\n");
                compile_lambda_expression(arg, params, lambda_code, offset, max_size, "arg_temp");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            args_array[%d] = arg_temp;\n", i);
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        }\n");
                temp = cdr(temp);
            }
        }
        
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        if (func && is_procedure(func)) {\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "            result = call_procedure(func, args_array, %d);\n", arg_count);
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        } else {\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "            result = scheme_nil;\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        }\n");
    } else {
        // No arguments
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        if (func && is_procedure(func)) {\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "            result = call_procedure(func, NULL, 0);\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        } else {\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "            result = scheme_nil;\n");
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        }\n");
    }
    
    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                       "    }\n");
}

// Helper function to compile any expression in lambda bodies
void compile_lambda_expression(SchemeObject* expr, SchemeObject* params, char* lambda_code, int* offset, int max_size, const char* result_var) {
    if (!expr) {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        %s = scheme_nil;\n", result_var);
        return;
    }
    
    if (is_number(expr)) {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        %s = make_number(%.6g);\n", result_var, expr->value.number_value);
    } else if (is_symbol(expr)) {
        // Check if it's a parameter reference
        bool is_param = false;
        SchemeObject* param_check = params;
        while (param_check && is_pair(param_check)) {
            if (is_symbol(car(param_check)) && strcmp(car(param_check)->value.symbol_name, expr->value.symbol_name) == 0) {
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        %s = local_%s;\n", result_var, expr->value.symbol_name);
                is_param = true;
                break;
            }
            param_check = cdr(param_check);
        }
        if (!is_param) {
            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                               "        %s = lookup_variable(\"%s\");\n", result_var, expr->value.symbol_name);
        }
    } else if (is_boolean(expr)) {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        %s = make_boolean(%s);\n", result_var, expr->value.boolean_value ? "true" : "false");
    } else if (is_string(expr)) {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        %s = make_string(\"%s\");\n", result_var, expr->value.string_value);
    } else if (is_pair(expr)) {
        // Handle compound expressions recursively
        SchemeObject* op = car(expr);
        if (is_symbol(op)) {
            const char* op_name = op->value.symbol_name;
            
            // Handle arithmetic and comparison operations
            if (strcmp(op_name, "=") == 0) {
                SchemeObject* arg1 = car(cdr(expr));
                SchemeObject* arg2 = car(cdr(cdr(expr)));
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        {\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp1;\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp2;\n");
                compile_lambda_expression(arg1, params, lambda_code, offset, max_size, "temp1");
                compile_lambda_expression(arg2, params, lambda_code, offset, max_size, "temp2");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            %s = scheme_equal(temp1, temp2);\n", result_var);
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        }\n");
            } else if (strcmp(op_name, "*") == 0) {
                SchemeObject* arg1 = car(cdr(expr));
                SchemeObject* arg2 = car(cdr(cdr(expr)));
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        {\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp1;\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp2;\n");
                compile_lambda_expression(arg1, params, lambda_code, offset, max_size, "temp1");
                compile_lambda_expression(arg2, params, lambda_code, offset, max_size, "temp2");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            %s = scheme_multiply(temp1, temp2);\n", result_var);
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        }\n");
            } else if (strcmp(op_name, "-") == 0) {
                SchemeObject* arg1 = car(cdr(expr));
                SchemeObject* arg2 = car(cdr(cdr(expr)));
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        {\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp1;\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* temp2;\n");
                compile_lambda_expression(arg1, params, lambda_code, offset, max_size, "temp1");
                compile_lambda_expression(arg2, params, lambda_code, offset, max_size, "temp2");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            %s = scheme_subtract(temp1, temp2);\n", result_var);
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        }\n");
            } else {
                // Function call
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        {\n");
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "            SchemeObject* func = lookup_variable(\"%s\");\n", op_name);
                
                // Count arguments
                int arg_count = 0;
                SchemeObject* temp = cdr(expr);
                while (temp && is_pair(temp)) {
                    arg_count++;
                    temp = cdr(temp);
                }
                
                if (arg_count > 0) {
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            SchemeObject* args_array[%d];\n", arg_count);
                    
                    temp = cdr(expr);
                    for (int i = 0; i < arg_count; i++) {
                        if (temp && is_pair(temp)) {
                            SchemeObject* arg = car(temp);
                            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                               "            {\n");
                            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                               "                SchemeObject* arg_temp;\n");
                            compile_lambda_expression(arg, params, lambda_code, offset, max_size, "arg_temp");
                            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                               "                args_array[%d] = arg_temp;\n", i);
                            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                               "            }\n");
                            temp = cdr(temp);
                        }
                    }
                    
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            if (func && is_procedure(func)) {\n");
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "                %s = call_procedure(func, args_array, %d);\n", result_var, arg_count);
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            } else {\n");
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "                %s = scheme_nil;\n", result_var);
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            }\n");
                } else {
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            if (func && is_procedure(func)) {\n");
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "                %s = call_procedure(func, NULL, 0);\n", result_var);
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            } else {\n");
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "                %s = scheme_nil;\n", result_var);
                    *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                       "            }\n");
                }
                
                *offset += snprintf(lambda_code + *offset, max_size - *offset,
                                   "        }\n");
            }
        } else {
            *offset += snprintf(lambda_code + *offset, max_size - *offset,
                               "        %s = scheme_nil; // Non-symbol operator\n", result_var);
        }
    } else {
        *offset += snprintf(lambda_code + *offset, max_size - *offset,
                           "        %s = scheme_nil; // Unsupported expression type\n", result_var);
    }
}

void compile_define(SchemeObject* args, CompilerContext* ctx) {
    emit_comment(ctx, "Define variable");
    
    if (!args || is_nil(args)) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    SchemeObject* var = car(args);
    SchemeObject* value_expr = car(cdr(args));
    
    if (!var || !is_symbol(var)) {
        emit_line(ctx, "result = scheme_nil; // Invalid variable name");
        return;
    }
    
    // Compile the value expression
    compile_expression(value_expr, ctx);
    
    // Store the result in the variable
    emit_line(ctx, "define_variable(\"%s\", result);", var->value.symbol_name);
    emit_line(ctx, "// Variable '%s' defined", var->value.symbol_name);
}

void compile_set(SchemeObject* args, CompilerContext* ctx) {
    emit_comment(ctx, "Set! - Variable assignment");
    
    if (!args || is_nil(args)) {
        emit_line(ctx, "result = scheme_nil; // No arguments to set!");
        return;
    }
    
    SchemeObject* var = car(args);
    SchemeObject* value_args = cdr(args);
    
    if (!value_args || is_nil(value_args)) {
        emit_line(ctx, "result = scheme_nil; // No value provided for set!");
        return;
    }
    
    SchemeObject* value_expr = car(value_args);
    
    if (!var || !is_symbol(var)) {
        emit_line(ctx, "result = scheme_nil; // Invalid variable name for set!");
        return;
    }
    
    // Compile the value expression
    compile_expression(value_expr, ctx);
    
    // Set the variable value (reuse define_variable which handles updates)
    emit_line(ctx, "define_variable(\"%s\", result);", var->value.symbol_name);
    emit_line(ctx, "// Variable '%s' updated via set!", var->value.symbol_name);
}

void compile_begin(SchemeObject* args, CompilerContext* ctx) {
    emit_comment(ctx, "Begin sequence");
    
    SchemeObject* current = args;
    while (current && !is_nil(current)) {
        compile_expression(car(current), ctx);
        current = cdr(current);
        if (current && !is_nil(current)) {
            emit_line(ctx, "// Discard intermediate result");
        }
    }
}

void optimize_dead_code(SchemeObject* expr) {
    (void)expr;
}

void emit_lambda_functions(CompilerContext* ctx) {
    fprintf(ctx->output, "// DEBUG: Attempting to emit lambda functions\n");
    LambdaFunction* current = ctx->lambda_functions;
    if (!current) {
        fprintf(ctx->output, "// DEBUG: No lambda functions found in context\n");
        return;
    }
    
    fprintf(ctx->output, "// Lambda function declarations\n");
    int count = 0;
    while (current) {
        count++;
        fprintf(ctx->output, "// DEBUG: Emitting lambda function %d: %s\n", count, current->name);
        fprintf(ctx->output, "%s", current->code);
        current = current->next;
    }
    fprintf(ctx->output, "// DEBUG: Emitted %d lambda functions\n\n", count);
}