#include "rscheme.h"
#include <stdarg.h>

CompilerContext* create_compiler_context(FILE* output, Environment* env, bool optimize) {
    CompilerContext* ctx = (CompilerContext*)scheme_malloc(sizeof(CompilerContext));
    ctx->output = output;
    ctx->env = env;
    ctx->indent_level = 0;
    ctx->temp_var_counter = 0;
    ctx->label_counter = 0;
    ctx->optimize = optimize;
    ctx->current_function = NULL;
    return ctx;
}

void destroy_compiler_context(CompilerContext* ctx) {
    if (ctx) {
        if (ctx->current_function) {
            scheme_free(ctx->current_function);
        }
        scheme_free(ctx);
    }
}

void emit_indent(CompilerContext* ctx) {
    for (int i = 0; i < ctx->indent_level; i++) {
        fprintf(ctx->output, "    ");
    }
}

void emit_line(CompilerContext* ctx, const char* format, ...) {
    va_list args;
    va_start(args, format);
    emit_indent(ctx);
    vfprintf(ctx->output, format, args);
    fprintf(ctx->output, "\n");
    va_end(args);
}

void emit_comment(CompilerContext* ctx, const char* comment) {
    emit_line(ctx, "// %s", comment);
}

char* generate_temp_var(CompilerContext* ctx) {
    char* var = scheme_malloc(32);
    snprintf(var, 32, "temp_%d", ctx->temp_var_counter++);
    return var;
}

char* generate_label(CompilerContext* ctx) {
    char* label = scheme_malloc(32);
    snprintf(label, 32, "label_%d", ctx->label_counter++);
    return label;
}

void generate_c_header(CompilerContext* ctx) {
    fprintf(ctx->output, "// Generated by RScheme compiler\n");
    fprintf(ctx->output, "#include <stdio.h>\n");
    fprintf(ctx->output, "#include <stdlib.h>\n");
    fprintf(ctx->output, "#include <string.h>\n");
    fprintf(ctx->output, "#include <stdbool.h>\n");
    fprintf(ctx->output, "#include <math.h>\n\n");
    
    fprintf(ctx->output, "// Scheme object types\n");
    fprintf(ctx->output, "typedef enum {\n");
    fprintf(ctx->output, "    SCHEME_NIL, SCHEME_BOOLEAN, SCHEME_NUMBER,\n");
    fprintf(ctx->output, "    SCHEME_SYMBOL, SCHEME_STRING, SCHEME_PAIR,\n");
    fprintf(ctx->output, "    SCHEME_PROCEDURE, SCHEME_PRIMITIVE\n");
    fprintf(ctx->output, "} SchemeType;\n\n");
    
    fprintf(ctx->output, "typedef struct SchemeObject {\n");
    fprintf(ctx->output, "    SchemeType type;\n");
    fprintf(ctx->output, "    union {\n");
    fprintf(ctx->output, "        bool boolean_value;\n");
    fprintf(ctx->output, "        double number_value;\n");
    fprintf(ctx->output, "        char* string_value;\n");
    fprintf(ctx->output, "        struct { struct SchemeObject* car; struct SchemeObject* cdr; } pair;\n");
    fprintf(ctx->output, "    } value;\n");
    fprintf(ctx->output, "} SchemeObject;\n\n");
    
    generate_runtime_functions(ctx);
}

void generate_runtime_functions(CompilerContext* ctx) {
    fprintf(ctx->output, "// Runtime functions\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_nil;\n");
    fprintf(ctx->output, "SchemeObject* scheme_true;\n");
    fprintf(ctx->output, "SchemeObject* scheme_false;\n\n");
    
    // Object creation functions
    fprintf(ctx->output, "SchemeObject* make_number(double value) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_NUMBER;\n");
    fprintf(ctx->output, "    obj->value.number_value = value;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_boolean(bool value) {\n");
    fprintf(ctx->output, "    return value ? scheme_true : scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_string(const char* value) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_STRING;\n");
    fprintf(ctx->output, "    obj->value.string_value = malloc(strlen(value) + 1);\n");
    fprintf(ctx->output, "    strcpy(obj->value.string_value, value);\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* make_pair(SchemeObject* car, SchemeObject* cdr) {\n");
    fprintf(ctx->output, "    SchemeObject* obj = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    obj->type = SCHEME_PAIR;\n");
    fprintf(ctx->output, "    obj->value.pair.car = car;\n");
    fprintf(ctx->output, "    obj->value.pair.cdr = cdr;\n");
    fprintf(ctx->output, "    return obj;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Type predicates
    fprintf(ctx->output, "bool is_true(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj != scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_number(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_NUMBER;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_boolean(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_string(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_STRING;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_pair(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj && obj->type == SCHEME_PAIR;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "bool is_nil(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return obj == scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // List operations
    fprintf(ctx->output, "SchemeObject* car(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_pair(obj)) return obj->value.pair.car;\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* cdr(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_pair(obj)) return obj->value.pair.cdr;\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Arithmetic operations
    fprintf(ctx->output, "SchemeObject* scheme_add(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value + b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_subtract(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value - b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_multiply(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value * b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_divide(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b) && b->value.number_value != 0) {\n");
    fprintf(ctx->output, "        return make_number(a->value.number_value / b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Comparison operations
    fprintf(ctx->output, "SchemeObject* scheme_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value == b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_less_than(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value < b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater_than(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value > b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return make_boolean(false);\n");
    fprintf(ctx->output, "}\n\n");
    
    // Display function
    fprintf(ctx->output, "void scheme_display(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    if (is_number(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%g\", obj->value.number_value);\n");
    fprintf(ctx->output, "    } else if (is_boolean(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%s\", obj->value.boolean_value ? \"#t\" : \"#f\");\n");
    fprintf(ctx->output, "    } else if (is_string(obj)) {\n");
    fprintf(ctx->output, "        printf(\"%%s\", obj->value.string_value);\n");
    fprintf(ctx->output, "    } else if (is_nil(obj)) {\n");
    fprintf(ctx->output, "        printf(\"()\");\n");
    fprintf(ctx->output, "    } else {\n");
    fprintf(ctx->output, "        printf(\"(...)\");\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "void init_runtime() {\n");
    fprintf(ctx->output, "    scheme_nil = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_nil->type = SCHEME_NIL;\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    scheme_true = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_true->type = SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "    scheme_true->value.boolean_value = true;\n");
    fprintf(ctx->output, "    \n");
    fprintf(ctx->output, "    scheme_false = malloc(sizeof(SchemeObject));\n");
    fprintf(ctx->output, "    scheme_false->type = SCHEME_BOOLEAN;\n");
    fprintf(ctx->output, "    scheme_false->value.boolean_value = false;\n");
    fprintf(ctx->output, "}\n\n");
    
    // Additional runtime functions
    fprintf(ctx->output, "SchemeObject* scheme_less(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value < b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value > b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_less_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value <= b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_greater_equal(SchemeObject* a, SchemeObject* b) {\n");
    fprintf(ctx->output, "    if (is_number(a) && is_number(b)) {\n");
    fprintf(ctx->output, "        return make_boolean(a->value.number_value >= b->value.number_value);\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_false;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_car(SchemeObject* pair) {\n");
    fprintf(ctx->output, "    if (is_pair(pair)) {\n");
    fprintf(ctx->output, "        return pair->value.pair.car;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_cdr(SchemeObject* pair) {\n");
    fprintf(ctx->output, "    if (is_pair(pair)) {\n");
    fprintf(ctx->output, "        return pair->value.pair.cdr;\n");
    fprintf(ctx->output, "    }\n");
    fprintf(ctx->output, "    return scheme_nil;\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_number_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_number(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_boolean_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_BOOLEAN);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_string_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_STRING);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_symbol_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_SYMBOL);\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_pair_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_pair(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_null_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(is_nil(obj));\n");
    fprintf(ctx->output, "}\n\n");
    
    fprintf(ctx->output, "SchemeObject* scheme_procedure_p(SchemeObject* obj) {\n");
    fprintf(ctx->output, "    return make_boolean(obj && obj->type == SCHEME_PROCEDURE);\n");
    fprintf(ctx->output, "}\n\n");
}

void generate_main_function(CompilerContext* ctx, SchemeObject* expr) {
    fprintf(ctx->output, "int main() {\n");
    ctx->indent_level++;
    
    emit_line(ctx, "init_runtime();");
    emit_line(ctx, "SchemeObject* result;");
    emit_line(ctx, "");
    
    compile_expression(expr, ctx);
    
    emit_line(ctx, "");
    emit_line(ctx, "return 0;");
    
    ctx->indent_level--;
    fprintf(ctx->output, "}\n");
}

void compile_expression(SchemeObject* expr, CompilerContext* ctx) {
    if (!expr) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    switch (expr->type) {
        case SCHEME_NIL:
            emit_line(ctx, "result = scheme_nil;");
            break;
            
        case SCHEME_BOOLEAN:
            emit_line(ctx, "result = make_boolean(%s);", 
                     expr->value.boolean_value ? "true" : "false");
            break;
            
        case SCHEME_NUMBER:
            emit_line(ctx, "result = make_number(%.6g);", expr->value.number_value);
            break;
            
        case SCHEME_SYMBOL:
            // For now, compile symbols as built-in functions or variables
            emit_line(ctx, "// Symbol: %s", expr->value.symbol_name);
            emit_line(ctx, "result = scheme_nil; // Symbol lookup not implemented in compiler");
            break;
            
        case SCHEME_STRING:
            emit_line(ctx, "result = make_string(\"%s\");", expr->value.string_value);
            break;
            
        case SCHEME_PAIR:
            compile_application(expr, ctx);
            break;
            
        default:
            emit_line(ctx, "result = scheme_nil; // Unknown expression type");
            break;
    }
}

void compile_application(SchemeObject* expr, CompilerContext* ctx) {
    SchemeObject* operator = car(expr);
    SchemeObject* operands = cdr(expr);
    
    if (is_symbol(operator)) {
        const char* name = operator->value.symbol_name;
        
        // Special forms
        if (strcmp(name, "if") == 0) {
            compile_if(operands, ctx);
            return;
        } else if (strcmp(name, "define") == 0) {
            compile_define(operands, ctx);
            return;
        } else if (strcmp(name, "lambda") == 0) {
            compile_lambda(operands, ctx);
            return;
        } else if (strcmp(name, "begin") == 0) {
            compile_begin(operands, ctx);
            return;
        } else if (strcmp(name, "quote") == 0) {
            compile_quote(operands, ctx);
            return;
        }
        
        // Built-in procedures
        if (strcmp(name, "display") == 0) {
            emit_comment(ctx, "Display");
            if (operands && is_pair(operands)) {
                char* temp = generate_temp_var(ctx);
                emit_line(ctx, "SchemeObject* %s;", temp);
                compile_expression(car(operands), ctx);
                emit_line(ctx, "%s = result;", temp);
                emit_line(ctx, "scheme_display(%s);", temp);
                emit_line(ctx, "result = scheme_nil;");
                scheme_free(temp);
            } else {
                emit_line(ctx, "result = scheme_nil;");
            }
            return;
        } else if (strcmp(name, "newline") == 0) {
            emit_comment(ctx, "Newline");
            emit_line(ctx, "printf(\"\\n\");");
            emit_line(ctx, "result = scheme_nil;");
            return;
        } else if (strcmp(name, "+") == 0) {
            compile_arithmetic(operands, ctx, "add");
            return;
        } else if (strcmp(name, "-") == 0) {
            compile_arithmetic(operands, ctx, "subtract");
            return;
        } else if (strcmp(name, "*") == 0) {
            compile_arithmetic(operands, ctx, "multiply");
            return;
        } else if (strcmp(name, "/") == 0) {
            compile_arithmetic(operands, ctx, "divide");
            return;
        } else if (strcmp(name, "=") == 0) {
            compile_comparison(operands, ctx, "equal");
            return;
        } else if (strcmp(name, "<") == 0) {
            compile_comparison(operands, ctx, "less");
            return;
        } else if (strcmp(name, ">") == 0) {
            compile_comparison(operands, ctx, "greater");
            return;
        } else if (strcmp(name, "<=") == 0) {
            compile_comparison(operands, ctx, "less_equal");
            return;
        } else if (strcmp(name, ">=") == 0) {
            compile_comparison(operands, ctx, "greater_equal");
            return;
        } else if (strcmp(name, "cons") == 0) {
            compile_cons(operands, ctx);
            return;
        } else if (strcmp(name, "car") == 0) {
            compile_car_cdr(operands, ctx, "car");
            return;
        } else if (strcmp(name, "cdr") == 0) {
            compile_car_cdr(operands, ctx, "cdr");
            return;
        } else if (strcmp(name, "number?") == 0) {
            compile_type_predicate(operands, ctx, "number_p");
            return;
        } else if (strcmp(name, "boolean?") == 0) {
            compile_type_predicate(operands, ctx, "boolean_p");
            return;
        } else if (strcmp(name, "string?") == 0) {
            compile_type_predicate(operands, ctx, "string_p");
            return;
        } else if (strcmp(name, "symbol?") == 0) {
            compile_type_predicate(operands, ctx, "symbol_p");
            return;
        } else if (strcmp(name, "pair?") == 0) {
            compile_type_predicate(operands, ctx, "pair_p");
            return;
        } else if (strcmp(name, "null?") == 0) {
            compile_type_predicate(operands, ctx, "null_p");
            return;
        } else if (strcmp(name, "procedure?") == 0) {
            compile_type_predicate(operands, ctx, "procedure_p");
            return;
        }
    }
    
    emit_comment(ctx, "Generic application not implemented");
    emit_line(ctx, "result = scheme_nil;");
}

void compile_if(SchemeObject* args, CompilerContext* ctx) {
    if (!args || !is_pair(args)) {
        emit_line(ctx, "result = scheme_nil; // Invalid if expression");
        return;
    }
    
    SchemeObject* test = car(args);
    args = cdr(args);
    
    if (!args || !is_pair(args)) {
        emit_line(ctx, "result = scheme_nil; // Invalid if expression");
        return;
    }
    
    SchemeObject* then_expr = car(args);
    args = cdr(args);
    SchemeObject* else_expr = (args && is_pair(args)) ? car(args) : SCHEME_NIL_OBJECT;
    
    char* temp_var = generate_temp_var(ctx);
    char* else_label = generate_label(ctx);
    char* end_label = generate_label(ctx);
    
    emit_comment(ctx, "if expression");
    emit_line(ctx, "SchemeObject* %s;", temp_var);
    
    // Compile test
    compile_expression(test, ctx);
    emit_line(ctx, "%s = result;", temp_var);
    
    emit_line(ctx, "if (!is_true(%s)) goto %s;", temp_var, else_label);
    
    // Then branch
    compile_expression(then_expr, ctx);
    emit_line(ctx, "goto %s;", end_label);
    
    // Else branch
    emit_line(ctx, "%s:", else_label);
    compile_expression(else_expr, ctx);
    
    emit_line(ctx, "%s:", end_label);
    
    scheme_free(temp_var);
    scheme_free(else_label);
    scheme_free(end_label);
}

bool compile_to_c(SchemeObject* expr, const char* output_file, bool optimize) {
    FILE* output = fopen(output_file, "w");
    if (!output) {
        runtime_error("Cannot open output file: %s", output_file);
        return false;
    }
    
    CompilerContext* ctx = create_compiler_context(output, NULL, optimize);
    
    generate_c_header(ctx);
    generate_main_function(ctx, expr);
    
    destroy_compiler_context(ctx);
    fclose(output);
    
    return true;
}

bool compile_file(const char* input_file, const char* output_file, bool optimize) {
    FILE* input = fopen(input_file, "rb");  // Use binary mode like the interpreter
    if (!input) {
        runtime_error("Cannot open input file: %s", input_file);
        return false;
    }
    
    // Read entire file
    fseek(input, 0, SEEK_END);
    long length = ftell(input);
    fseek(input, 0, SEEK_SET);
    
    char* content = (char*)scheme_malloc(length + 1);
    fread(content, 1, length, input);
    content[length] = '\0';
    fclose(input);
    
    // Parse all expressions
    Parser* parser = create_parser(content);
    
    FILE* output = fopen(output_file, "w");
    if (!output) {
        runtime_error("Cannot open output file: %s", output_file);
        scheme_free(content);
        destroy_parser(parser);
        return false;
    }
    
    CompilerContext* ctx = create_compiler_context(output, NULL, optimize);
    
    generate_c_header(ctx);
    
    // Generate main function start
    fprintf(ctx->output, "int main() {\n");
    fprintf(ctx->output, "    init_runtime();\n");
    fprintf(ctx->output, "    SchemeObject* result;\n\n");
    
    // Compile all expressions in sequence
    bool success = true;
    while (true) {
        SchemeObject* expr = parse_expression(parser);
        
        if (has_parse_error(parser)) {
            print_parse_error(parser, stderr);
            success = false;
            break;
        }
        
        if (!expr) {
            break; // End of input
        }
        
        compile_expression(expr, ctx);
        fprintf(ctx->output, "\n");
    }
    
    // Generate main function end
    fprintf(ctx->output, "    return 0;\n");
    fprintf(ctx->output, "}\n");
    
    destroy_compiler_context(ctx);
    fclose(output);
    destroy_parser(parser);
    scheme_free(content);
    
    return success;
}

void compile_arithmetic(SchemeObject* operands, CompilerContext* ctx, const char* op) {
    emit_comment(ctx, "Arithmetic operation");
    
    if (!operands || is_nil(operands)) {
        // Empty operation - for + and * return identity
        if (strcmp(op, "add") == 0 || strcmp(op, "multiply") == 0) {
            emit_line(ctx, "result = make_number(%s);", 
                     strcmp(op, "add") == 0 ? "0" : "1");
        } else {
            emit_line(ctx, "result = scheme_nil; // Invalid empty operation");
        }
        return;
    }
    
    // Compile first operand
    char* temp1 = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp1);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    operands = cdr(operands);
    
    if (!operands || is_nil(operands)) {
        // Single operand - for - and / this is negation/reciprocal
        if (strcmp(op, "subtract") == 0) {
            emit_line(ctx, "result = make_number(-%s->value.number_value);", temp1);
        } else if (strcmp(op, "divide") == 0) {
            emit_line(ctx, "result = make_number(1.0 / %s->value.number_value);", temp1);
        } else {
            emit_line(ctx, "result = %s;", temp1);
        }
    } else {
        // Multiple operands
        while (operands && !is_nil(operands)) {
            char* temp2 = generate_temp_var(ctx);
            emit_line(ctx, "SchemeObject* %s;", temp2);
            compile_expression(car(operands), ctx);
            emit_line(ctx, "%s = result;", temp2);
            emit_line(ctx, "%s = scheme_%s(%s, %s);", temp1, op, temp1, temp2);
            scheme_free(temp2);
            operands = cdr(operands);
        }
        emit_line(ctx, "result = %s;", temp1);
    }
    
    scheme_free(temp1);
}

void compile_comparison(SchemeObject* operands, CompilerContext* ctx, const char* op) {
    emit_comment(ctx, "Comparison operation");
    
    if (!operands || is_nil(operands) || !cdr(operands) || is_nil(cdr(operands))) {
        emit_line(ctx, "result = make_boolean(true); // Vacuous truth");
        return;
    }
    
    char* done_label = generate_label(ctx);
    char* temp1 = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp1);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    operands = cdr(operands);
    
    while (operands && !is_nil(operands)) {
        char* temp2 = generate_temp_var(ctx);
        emit_line(ctx, "SchemeObject* %s;", temp2);
        compile_expression(car(operands), ctx);
        emit_line(ctx, "%s = result;", temp2);
        emit_line(ctx, "if (!is_true(scheme_%s(%s, %s))) {", op, temp1, temp2);
        emit_line(ctx, "    result = make_boolean(false);");
        emit_line(ctx, "    goto %s;", done_label);
        emit_line(ctx, "}");
        emit_line(ctx, "%s = %s;", temp1, temp2);
        scheme_free(temp2);
        operands = cdr(operands);
    }
    
    emit_line(ctx, "result = make_boolean(true);");
    emit_line(ctx, "%s:;", done_label);
    scheme_free(temp1);
    scheme_free(done_label);
}

void compile_cons(SchemeObject* operands, CompilerContext* ctx) {
    emit_comment(ctx, "Cons operation");
    
    if (!operands || is_nil(operands) || !cdr(operands) || is_nil(cdr(operands))) {
        emit_line(ctx, "result = scheme_nil; // Invalid cons");
        return;
    }
    
    char* temp1 = generate_temp_var(ctx);
    char* temp2 = generate_temp_var(ctx);
    
    emit_line(ctx, "SchemeObject* %s;", temp1);
    emit_line(ctx, "SchemeObject* %s;", temp2);
    
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp1);
    
    compile_expression(car(cdr(operands)), ctx);
    emit_line(ctx, "%s = result;", temp2);
    
    emit_line(ctx, "result = make_pair(%s, %s);", temp1, temp2);
    
    scheme_free(temp1);
    scheme_free(temp2);
}

void compile_car_cdr(SchemeObject* operands, CompilerContext* ctx, const char* operation) {
    emit_comment(ctx, operation);
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil; // Invalid %s", operation);
        return;
    }
    
    char* temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp);
    emit_line(ctx, "result = scheme_%s(%s);", operation, temp);
    scheme_free(temp);
}

void compile_type_predicate(SchemeObject* operands, CompilerContext* ctx, const char* predicate) {
    emit_comment(ctx, predicate);
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_false; // Invalid predicate");
        return;
    }
    
    char* temp = generate_temp_var(ctx);
    emit_line(ctx, "SchemeObject* %s;", temp);
    compile_expression(car(operands), ctx);
    emit_line(ctx, "%s = result;", temp);
    emit_line(ctx, "result = scheme_%s(%s);", predicate, temp);
    scheme_free(temp);
}

void compile_quote(SchemeObject* operands, CompilerContext* ctx) {
    emit_comment(ctx, "Quote");
    
    if (!operands || is_nil(operands)) {
        emit_line(ctx, "result = scheme_nil;");
        return;
    }
    
    // For simple compilation, just handle basic quoted values
    SchemeObject* quoted = car(operands);
    if (is_number(quoted)) {
        emit_line(ctx, "result = make_number(%.6g);", quoted->value.number_value);
    } else if (is_boolean(quoted)) {
        emit_line(ctx, "result = make_boolean(%s);", quoted->value.boolean_value ? "true" : "false");
    } else if (is_string(quoted)) {
        emit_line(ctx, "result = make_string(\"%s\");", quoted->value.string_value);
    } else if (is_nil(quoted)) {
        emit_line(ctx, "result = scheme_nil;");
    } else {
        emit_line(ctx, "result = scheme_nil; // Complex quoted structure not implemented");
    }
}

void compile_lambda(SchemeObject* args, CompilerContext* ctx) {
    (void)args; (void)ctx;
    emit_line(ctx, "result = scheme_nil; // Lambda compilation not implemented in simple compiler");
}

void compile_define(SchemeObject* args, CompilerContext* ctx) {
    (void)args; (void)ctx;
    emit_line(ctx, "result = scheme_nil; // Define compilation not implemented in simple compiler");
}

void compile_set(SchemeObject* args, CompilerContext* ctx) {
    (void)args; (void)ctx;
    emit_line(ctx, "result = scheme_nil; // Set! compilation not implemented in simple compiler");
}

void compile_begin(SchemeObject* args, CompilerContext* ctx) {
    emit_comment(ctx, "Begin sequence");
    
    SchemeObject* current = args;
    while (current && !is_nil(current)) {
        compile_expression(car(current), ctx);
        current = cdr(current);
        if (current && !is_nil(current)) {
            emit_line(ctx, "// Discard intermediate result");
        }
    }
}

void optimize_dead_code(SchemeObject* expr) {
    (void)expr;
}