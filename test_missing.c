// Generated by RScheme compiler
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <math.h>

// Forward declarations
typedef struct Environment Environment;

// Scheme object types
typedef enum {
    SCHEME_NIL, SCHEME_BOOLEAN, SCHEME_NUMBER,
    SCHEME_SYMBOL, SCHEME_STRING, SCHEME_PAIR,
    SCHEME_PROCEDURE, SCHEME_PRIMITIVE
} SchemeType;

typedef struct SchemeObject {
    SchemeType type;
    union {
        bool boolean_value;
        double number_value;
        char* string_value;
        char* symbol_name;
        struct { struct SchemeObject* car; struct SchemeObject* cdr; } pair;
        struct {
            struct SchemeObject* parameters;  // List of parameter symbols (for interpreted)
            struct SchemeObject* body;        // List of expressions (for interpreted)
            Environment* closure;             // Captured environment (for interpreted)
            struct SchemeObject* (*func)(struct SchemeObject**, int); // Function pointer (for compiled)
            int arity;                        // Number of parameters
            char* name;                       // Function name (for debugging)
        } procedure;
    } value;
} SchemeObject;

// Runtime functions
SchemeObject* scheme_nil;
SchemeObject* scheme_true;
SchemeObject* scheme_false;

// Function declarations
void scheme_display(SchemeObject* obj);
void scheme_display_list(SchemeObject* obj);
SchemeObject* lookup_variable(const char* name);
void define_variable(const char* name, SchemeObject* value);

// Global variables (simple implementation)
#define MAX_VARS 100
char* var_names[MAX_VARS];
SchemeObject* var_values[MAX_VARS];
int var_count = 0;

// Runtime functions
SchemeObject* scheme_nil;
SchemeObject* scheme_true;
SchemeObject* scheme_false;

SchemeObject* make_number(double value) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_NUMBER;
    obj->value.number_value = value;
    return obj;
}

SchemeObject* make_boolean(bool value) {
    return value ? scheme_true : scheme_false;
}

SchemeObject* make_string(const char* value) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_STRING;
    obj->value.string_value = malloc(strlen(value) + 1);
    strcpy(obj->value.string_value, value);
    return obj;
}

SchemeObject* make_symbol(const char* name) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_SYMBOL;
    obj->value.symbol_name = malloc(strlen(name) + 1);
    strcpy(obj->value.symbol_name, name);
    return obj;
}

SchemeObject* make_pair(SchemeObject* car, SchemeObject* cdr) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PAIR;
    obj->value.pair.car = car;
    obj->value.pair.cdr = cdr;
    return obj;
}

bool is_true(SchemeObject* obj) {
    return obj != scheme_false;
}

bool is_number(SchemeObject* obj) {
    return obj && obj->type == SCHEME_NUMBER;
}

bool is_boolean(SchemeObject* obj) {
    return obj && obj->type == SCHEME_BOOLEAN;
}

bool is_string(SchemeObject* obj) {
    return obj && obj->type == SCHEME_STRING;
}

bool is_pair(SchemeObject* obj) {
    return obj && obj->type == SCHEME_PAIR;
}

bool is_nil(SchemeObject* obj) {
    return obj == scheme_nil;
}

bool is_procedure(SchemeObject* obj) {
    return obj && obj->type == SCHEME_PROCEDURE;
}

bool is_symbol(SchemeObject* obj) {
    return obj && obj->type == SCHEME_SYMBOL;
}

SchemeObject* call_procedure(SchemeObject* proc, SchemeObject** args, int argc) {
    if (!proc || !is_procedure(proc)) {
        return scheme_nil;
    }
    
    // Check if it's a compiled procedure (has func pointer)
    if (proc->value.procedure.func) {
        return proc->value.procedure.func(args, argc);
    }
    
    // For interpreted procedures, we can't handle them in compiled code
    // This would require a full interpreter runtime
    return scheme_nil;
}

SchemeObject* car(SchemeObject* obj) {
    if (is_pair(obj)) return obj->value.pair.car;
    return scheme_nil;
}

SchemeObject* cdr(SchemeObject* obj) {
    if (is_pair(obj)) return obj->value.pair.cdr;
    return scheme_nil;
}

SchemeObject* scheme_add(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value + b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_subtract(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value - b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_multiply(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_number(a->value.number_value * b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_divide(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b) && b->value.number_value != 0) {
        return make_number(a->value.number_value / b->value.number_value);
    }
    return scheme_nil;
}

SchemeObject* scheme_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value == b->value.number_value);
    }
    return make_boolean(false);
}

SchemeObject* scheme_less_than(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value < b->value.number_value);
    }
    return make_boolean(false);
}

SchemeObject* scheme_greater_than(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value > b->value.number_value);
    }
    return make_boolean(false);
}

void scheme_display(SchemeObject* obj) {
    if (is_number(obj)) {
        printf("%g", obj->value.number_value);
    } else if (is_boolean(obj)) {
        printf("%s", obj->value.boolean_value ? "#t" : "#f");
    } else if (is_string(obj)) {
        printf("%s", obj->value.string_value);
    } else if (obj && obj->type == SCHEME_SYMBOL) {
        printf("%s", obj->value.symbol_name);
    } else if (is_pair(obj)) {
        scheme_display_list(obj);
    } else if (is_nil(obj)) {
        printf("()");
    } else {
        printf("(...)");
    }
}

void scheme_display_list(SchemeObject* obj) {
    printf("(");
    while (is_pair(obj)) {
        scheme_display(obj->value.pair.car);
        obj = obj->value.pair.cdr;
        if (is_pair(obj)) {
            printf(" ");
        } else if (!is_nil(obj)) {
            printf(" . ");
            scheme_display(obj);
        }
    }
    printf(")");
}

void init_runtime() {
    scheme_nil = malloc(sizeof(SchemeObject));
    scheme_nil->type = SCHEME_NIL;
    
    scheme_true = malloc(sizeof(SchemeObject));
    scheme_true->type = SCHEME_BOOLEAN;
    scheme_true->value.boolean_value = true;
    
    scheme_false = malloc(sizeof(SchemeObject));
    scheme_false->type = SCHEME_BOOLEAN;
    scheme_false->value.boolean_value = false;
}

SchemeObject* scheme_less(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value < b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_greater(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value > b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_less_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value <= b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_greater_equal(SchemeObject* a, SchemeObject* b) {
    if (is_number(a) && is_number(b)) {
        return make_boolean(a->value.number_value >= b->value.number_value);
    }
    return scheme_false;
}

SchemeObject* scheme_car(SchemeObject* pair) {
    if (is_pair(pair)) {
        return pair->value.pair.car;
    }
    return scheme_nil;
}

SchemeObject* scheme_cdr(SchemeObject* pair) {
    if (is_pair(pair)) {
        return pair->value.pair.cdr;
    }
    return scheme_nil;
}

SchemeObject* scheme_cons(SchemeObject* car, SchemeObject* cdr) {
    return make_pair(car, cdr);
}

SchemeObject* make_compiled_procedure(SchemeObject* (*func)(SchemeObject**, int), int arity, const char* name) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PROCEDURE;
    obj->value.procedure.func = func;
    obj->value.procedure.arity = arity;
    obj->value.procedure.name = malloc(strlen(name) + 1);
    strcpy(obj->value.procedure.name, name);
    obj->value.procedure.parameters = NULL;
    obj->value.procedure.body = NULL;
    obj->value.procedure.closure = NULL;
    return obj;
}

SchemeObject* make_procedure(SchemeObject* params, SchemeObject* body, Environment* env) {
    SchemeObject* obj = malloc(sizeof(SchemeObject));
    obj->type = SCHEME_PROCEDURE;
    obj->value.procedure.parameters = params;
    obj->value.procedure.body = body;
    obj->value.procedure.closure = env;
    obj->value.procedure.func = NULL; // Interpreted procedure
    obj->value.procedure.arity = 0;
    obj->value.procedure.name = NULL;
    return obj;
}

SchemeObject* scheme_number_p(SchemeObject* obj) {
    return make_boolean(is_number(obj));
}

SchemeObject* scheme_boolean_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_BOOLEAN);
}

SchemeObject* scheme_string_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_STRING);
}

SchemeObject* scheme_symbol_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_SYMBOL);
}

SchemeObject* scheme_pair_p(SchemeObject* obj) {
    return make_boolean(is_pair(obj));
}

SchemeObject* scheme_null_p(SchemeObject* obj) {
    return make_boolean(is_nil(obj));
}

SchemeObject* scheme_procedure_p(SchemeObject* obj) {
    return make_boolean(obj && obj->type == SCHEME_PROCEDURE);
}

SchemeObject* scheme_length(SchemeObject* obj) {
    int count = 0;
    while (is_pair(obj)) {
        count++;
        obj = obj->value.pair.cdr;
    }
    return make_number(count);
}

SchemeObject* scheme_string_length(SchemeObject* obj) {
    if (obj && obj->type == SCHEME_STRING) {
        return make_number(strlen(obj->value.string_value));
    }
    return scheme_nil;
}

SchemeObject* scheme_string_ref(SchemeObject* str, SchemeObject* index) {
    if (str && str->type == SCHEME_STRING && is_number(index)) {
        int idx = (int)index->value.number_value;
        int len = strlen(str->value.string_value);
        if (idx >= 0 && idx < len) {
            char result[2];
            result[0] = str->value.string_value[idx];
            result[1] = 0;
            return make_string(result);
        }
    }
    return scheme_nil;
}

SchemeObject* scheme_list_ref(SchemeObject* list, SchemeObject* index) {
    if (!is_number(index)) return scheme_nil;
    int idx = (int)index->value.number_value;
    if (idx < 0) return scheme_nil;
    SchemeObject* current = list;
    for (int i = 0; i < idx && is_pair(current); i++) {
        current = current->value.pair.cdr;
    }
    if (is_pair(current)) {
        return current->value.pair.car;
    }
    return scheme_nil;
}

SchemeObject* scheme_append(SchemeObject* list1, SchemeObject* list2) {
    if (is_nil(list1)) return list2;
    if (is_nil(list2)) return list1;
    if (!is_pair(list1)) return list2;
    // Create a new list by copying list1 and appending list2
    SchemeObject* result = scheme_nil;
    SchemeObject* tail = NULL;
    SchemeObject* current = list1;
    // Copy all elements from list1
    while (is_pair(current)) {
        SchemeObject* new_pair = make_pair(current->value.pair.car, scheme_nil);
        if (is_nil(result)) {
            result = new_pair;
            tail = new_pair;
        } else {
            tail->value.pair.cdr = new_pair;
            tail = new_pair;
        }
        current = current->value.pair.cdr;
    }
    // Append list2 to the end
    if (tail) {
        tail->value.pair.cdr = list2;
    } else {
        result = list2;
    }
    return result;
}

SchemeObject* scheme_reverse(SchemeObject* list) {
    SchemeObject* result = scheme_nil;
    SchemeObject* current = list;
    while (is_pair(current)) {
        result = make_pair(current->value.pair.car, result);
        current = current->value.pair.cdr;
    }
    return result;
}

SchemeObject* lookup_variable(const char* name) {
    for (int i = 0; i < var_count; i++) {
        if (strcmp(var_names[i], name) == 0) {
            return var_values[i];
        }
    }
    return make_symbol(name); // Return symbol if not found
}

void define_variable(const char* name, SchemeObject* value) {
    // Check if variable already exists
    for (int i = 0; i < var_count; i++) {
        if (strcmp(var_names[i], name) == 0) {
            var_values[i] = value;
            return;
        }
    }
    // Add new variable
    if (var_count < MAX_VARS) {
        var_names[var_count] = malloc(strlen(name) + 1);
        strcpy(var_names[var_count], name);
        var_values[var_count] = value;
        var_count++;
    }
}

// DEBUG: About to emit lambda functions
// DEBUG: Attempting to emit lambda functions
// Lambda function declarations
// DEBUG: Emitting lambda function 1: lambda_func_0
// Generated lambda function
SchemeObject* lambda_func_0(SchemeObject** args, int argc) {
    SchemeObject* result;
    // Bind parameters locally
    SchemeObject* local_x = (argc > 0) ? args[0] : scheme_nil;
    // Function body
    {
        SchemeObject* temp1;
        SchemeObject* temp2;
        temp1 = local_x;
        temp2 = local_x;
        result = scheme_multiply(temp1, temp2);
    }
    return result;
}

// DEBUG: Emitted 1 lambda functions

// DEBUG: Finished emitting lambda functions
int main() {
    init_runtime();
    SchemeObject* result;

// Display
SchemeObject* temp_0;
result = make_string("Testing missing R5RS functions:");
temp_0 = result;
scheme_display(temp_0);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_1;
result = make_string("list-ref test: ");
temp_1 = result;
scheme_display(temp_1);
result = scheme_nil;

// Display
SchemeObject* temp_2;
// list_ref
SchemeObject* temp_3;
SchemeObject* temp_4;
// Quote
// Building simple quoted list
{
    SchemeObject* elements[5];
    elements[0] = make_symbol("a");
    elements[1] = make_symbol("b");
    elements[2] = make_symbol("c");
    elements[3] = make_symbol("d");
    elements[4] = make_symbol("e");
    result = scheme_nil;
    result = make_pair(elements[4], result);
    result = make_pair(elements[3], result);
    result = make_pair(elements[2], result);
    result = make_pair(elements[1], result);
    result = make_pair(elements[0], result);
}
temp_3 = result;
result = make_number(2);
temp_4 = result;
result = scheme_list_ref(temp_3, temp_4);
temp_2 = result;
scheme_display(temp_2);
result = scheme_nil;

// Display
SchemeObject* temp_5;
result = make_string(" (should be c)");
temp_5 = result;
scheme_display(temp_5);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_6;
result = make_string("append test: ");
temp_6 = result;
scheme_display(temp_6);
result = scheme_nil;

// Display
SchemeObject* temp_7;
// Append
SchemeObject* temp_8;
SchemeObject* temp_9;
// Quote
// Building simple quoted list
{
    SchemeObject* elements[2];
    elements[0] = make_number(1);
    elements[1] = make_number(2);
    result = scheme_nil;
    result = make_pair(elements[1], result);
    result = make_pair(elements[0], result);
}
temp_8 = result;
// Quote
// Building simple quoted list
{
    SchemeObject* elements[2];
    elements[0] = make_number(3);
    elements[1] = make_number(4);
    result = scheme_nil;
    result = make_pair(elements[1], result);
    result = make_pair(elements[0], result);
}
temp_9 = result;
result = scheme_append(temp_8, temp_9);
temp_7 = result;
scheme_display(temp_7);
result = scheme_nil;

// Display
SchemeObject* temp_10;
result = make_string(" (should be (1 2 3 4))");
temp_10 = result;
scheme_display(temp_10);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_11;
result = make_string("reverse test: ");
temp_11 = result;
scheme_display(temp_11);
result = scheme_nil;

// Display
SchemeObject* temp_12;
// reverse
SchemeObject* temp_13;
// Quote
// Building simple quoted list
{
    SchemeObject* elements[4];
    elements[0] = make_number(1);
    elements[1] = make_number(2);
    elements[2] = make_number(3);
    elements[3] = make_number(4);
    result = scheme_nil;
    result = make_pair(elements[3], result);
    result = make_pair(elements[2], result);
    result = make_pair(elements[1], result);
    result = make_pair(elements[0], result);
}
temp_13 = result;
result = scheme_reverse(temp_13);
temp_12 = result;
scheme_display(temp_12);
result = scheme_nil;

// Display
SchemeObject* temp_14;
result = make_string(" (should be (4 3 2 1))");
temp_14 = result;
scheme_display(temp_14);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

// Display
SchemeObject* temp_15;
result = make_string("procedure? on lambda: ");
temp_15 = result;
scheme_display(temp_15);
result = scheme_nil;

// Display
SchemeObject* temp_16;
// procedure_p
SchemeObject* temp_17;
// Lambda expression
// Compiling lambda - collecting function
// Compiling lambda - collecting function
// Lambda args structure debugging
// Extracted body operator: *
// Lambda function collected successfully
result = make_compiled_procedure(lambda_func_0, 1, "lambda_func_0");
temp_17 = result;
result = scheme_procedure_p(temp_17);
temp_16 = result;
scheme_display(temp_16);
result = scheme_nil;

// Display
SchemeObject* temp_18;
result = make_string(" (should be #t)");
temp_18 = result;
scheme_display(temp_18);
result = scheme_nil;

// Newline
printf("\n");
result = scheme_nil;

    return 0;
}
